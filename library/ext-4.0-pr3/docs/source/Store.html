<!DOCTYPE html><html><head><title>Sencha Documentation Project</title><link rel="stylesheet" href="../reset.css" type="text/css"><link rel="stylesheet" href="../prettify.css" type="text/css"><link rel="stylesheet" href="http://localhost:3000/new/css/prettify_sa.css" type="text/css"><script type="text/javascript" src="../prettify.js"></script></head><body onload="prettyPrint()"><pre class="prettyprint"><pre><a name="cls-Ext.data.Store"></a>/**
 * @author Ed Spencer
 * @class Ext.data.Store
 * @extends Ext.data.AbstractStore
 *
 * &lt;p&gt;The Store class encapsulates a client side cache of {@link Ext.data.Model Model} objects. Stores load
 * data via a {@link Ext.data.Proxy Proxy}, and also provide functions for {@link #sort sorting},
 * {@link #filter filtering} and querying the {@link Ext.data.Model model} instances contained within it.&lt;/p&gt;
 *
 * &lt;p&gt;Creating a Store is easy - we just tell it the Model and the Proxy to use to load and save its data:&lt;/p&gt;
 *
<br><span style="display: none">**/</span>// Set up a {@link Ext.data.Model model} to use in our Store
Ext.regModel(&#39;User&#39;, {
    fields: [
        {name: &#39;firstName&#39;, type: &#39;string&#39;},
        {name: &#39;lastName&#39;,  type: &#39;string&#39;},
        {name: &#39;age&#39;,       type: &#39;int&#39;},
        {name: &#39;eyeColor&#39;,  type: &#39;string&#39;}
    ]
});

var myStore = new Ext.data.Store({
    model: &#39;User&#39;,
    proxy: {
        type: &#39;ajax&#39;,
        url : &#39;/users.json&#39;,
        reader: {
            type: &#39;json&#39;,
            root: &#39;users&#39;
        }
    },
    autoLoad: true
});
<br><span style="display: none">/**</span>
 * &lt;p&gt;In the example above we configured an AJAX proxy to load data from the url &#39;/users.json&#39;. We told our Proxy
 * to use a {@link Ext.data.JsonReader JsonReader} to parse the response from the server into Model object -
 * {@link Ext.data.JsonReader see the docs on JsonReader} for details.&lt;/p&gt;
 * 
 * &lt;p&gt;&lt;u&gt;Inline data&lt;/u&gt;&lt;/p&gt;
 * 
 * &lt;p&gt;Stores can also load data inline. Internally, Store converts each of the objects we pass in as {@link #data}
 * into Model instances:&lt;/p&gt;
 * 
<br><span style="display: none">**/</span>new Ext.data.Store({
    model: &#39;User&#39;,
    data : [
        {firstName: &#39;Ed&#39;,    lastName: &#39;Spencer&#39;},
        {firstName: &#39;Tommy&#39;, lastName: &#39;Maintz&#39;},
        {firstName: &#39;Aaron&#39;, lastName: &#39;Conran&#39;},
        {firstName: &#39;Jamie&#39;, lastName: &#39;Avins&#39;}
    ]
});
<br><span style="display: none">/**</span> *
 * &lt;p&gt;Loading inline data using the method above is great if the data is in the correct format already (e.g. it doesn&#39;t need 
 * to be processed by a {@link Ext.data.Reader reader}). If your inline data requires processing to decode the data structure,
 * use a {@link Ext.data.MemoryProxy MemoryProxy} instead (see the {@link Ext.data.MemoryProxy MemoryProxy} docs for an example).&lt;/p&gt;
 * 
 * &lt;p&gt;Additional data can also be loaded locally using {@link #add}.&lt;/p&gt;
 * 
 * &lt;p&gt;&lt;u&gt;Loading Nested Data&lt;/u&gt;&lt;/p&gt;
 * 
 * &lt;p&gt;Applications often need to load sets of associated data - for example a CRM system might load a User and her Orders. 
 * Instead of issuing an AJAX request for the User and a series of additional AJAX requests for each Order, we can load a nested dataset
 * and allow the Reader to automatically populate the associated models. Below is a brief example, see the {@link Ext.data.Reader} intro
 * docs for a full explanation:&lt;/p&gt;
 * 
<br><span style="display: none">**/</span>var store = new Ext.data.Store({
    autoLoad: true,
    model: &quot;User&quot;,
    proxy: {
        type: &#39;ajax&#39;,
        url : &#39;users.json&#39;,
        reader: {
            type: &#39;json&#39;,
            root: &#39;users&#39;
        }
    }
});
<br><span style="display: none">/**</span> * 
 * &lt;p&gt;Which would consume a response like this:&lt;/p&gt;
 * 
<br><span style="display: none">**/</span>{
    &quot;users&quot;: [
        {
            &quot;id&quot;: 1,
            &quot;name&quot;: &quot;Ed&quot;,
            &quot;orders&quot;: [
                {
                    &quot;id&quot;: 10,
                    &quot;total&quot;: 10.76,
                    &quot;status&quot;: &quot;invoiced&quot;
                },
                {
                    &quot;id&quot;: 11,
                    &quot;total&quot;: 13.45,
                    &quot;status&quot;: &quot;shipped&quot;
                }
            ]
        }
    ]
}
<br><span style="display: none">/**</span> * 
 * &lt;p&gt;See the {@link Ext.data.Reader} intro docs for a full explanation.&lt;/p&gt;
 * 
 * &lt;p&gt;&lt;u&gt;Filtering and Sorting&lt;/u&gt;&lt;/p&gt;
 * 
 * &lt;p&gt;Stores can be sorted and filtered - in both cases either remotely or locally. The {@link #sorters} and {@link #filters} are 
 * held inside {@link Ext.util.MixedCollection MixedCollection} instances to make them easy to manage. Usually it is sufficient to
 * either just specify sorters and filters in the Store configuration or call {@link #sort} or {@link #filter}:
 * 
<br><span style="display: none">**/</span>var store = new Ext.data.Store({
    model: &#39;User&#39;,
    sorters: [
        {
            property : &#39;age&#39;,
            direction: &#39;DESC&#39;
        },
        {
            property : &#39;firstName&#39;,
            direction: &#39;ASC&#39;
        }
    ],
    
    filters: [
        {
            property: &#39;firstName&#39;,
            value   : /Ed/
        }
    ]
});
<br><span style="display: none">/**</span> * 
 * &lt;p&gt;The new Store will keep the configured sorters and filters in the MixedCollection instances mentioned above. By default, sorting
 * and filtering are both performed locally by the Store - see {@link #remoteSort} and {@link #remoteFilter} to allow the server to 
 * perform these operations instead.&lt;/p&gt;
 * 
 * &lt;p&gt;Filtering and sorting after the Store has been instantiated is also easy. Calling {@link #filter} adds another filter to the Store
 * and automatically filters the dataset (calling {@link #filter} with no arguments simply re-applies all existing filters). Note that by
 * default {@link #sortOnFilter} is set to true, which means that your sorters are automatically reapplied if using local sorting.&lt;/p&gt;
 * 
<br><span style="display: none">**/</span>store.filter(&#39;eyeColor&#39;, &#39;Brown&#39;);
<br><span style="display: none">/**</span> * 
 * &lt;p&gt;Change the sorting at any time by calling {@link #sort}:&lt;/p&gt;
 * 
<br><span style="display: none">**/</span>store.sort(&#39;height&#39;, &#39;ASC&#39;);
<br><span style="display: none">/**</span> * 
 * &lt;p&gt;Note that all existing sorters will be removed in favor of the new sorter data (if {@link #sort} is called with no arguments, 
 * the existing sorters are just reapplied instead of being removed). To keep existing sorters and add new ones, just add them
 * to the MixedCollection:&lt;/p&gt;
 * 
<br><span style="display: none">**/</span>store.sorters.add(new Ext.util.Sorter({
    property : &#39;shoeSize&#39;,
    direction: &#39;ASC&#39;
}));

store.sort();
<br><span style="display: none">/**</span> * 
 * &lt;p&gt;&lt;u&gt;Registering with StoreMgr&lt;/u&gt;&lt;/p&gt;
 * 
 * &lt;p&gt;Any Store that is instantiated with a {@link #storeId} will automatically be registed with the {@link Ext.data.StoreMgr StoreMgr}.
 * This makes it easy to reuse the same store in multiple views:&lt;/p&gt;
 * 
 <br><span style="display: none">**/</span>//this store can be used several times
new Ext.data.Store({
    model: &#39;User&#39;,
    storeId: &#39;usersStore&#39;
});

new Ext.List({
    store: &#39;usersStore&#39;,

    //other config goes here
});

new Ext.DataView({
    store: &#39;usersStore&#39;,

    //other config goes here
});
<br><span style="display: none">/**</span> * 
 * &lt;p&gt;&lt;u&gt;Further Reading&lt;/u&gt;&lt;/p&gt;
 * 
 * &lt;p&gt;Stores are backed up by an ecosystem of classes that enables their operation. To gain a full understanding of these
 * pieces and how they fit together, see:&lt;/p&gt;
 * 
 * &lt;ul style=&quot;list-style-type: disc; padding-left: 25px&quot;&gt;
 * &lt;li&gt;{@link Ext.data.Proxy Proxy} - overview of what Proxies are and how they are used&lt;/li&gt;
 * &lt;li&gt;{@link Ext.data.Model Model} - the core class in the data package&lt;/li&gt;
 * &lt;li&gt;{@link Ext.data.Reader Reader} - used by any subclass of {@link Ext.data.ServerProxy ServerProxy} to read a response&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @constructor
 * @param {Object} config Optional config object
 */
Ext.define(&#39;Ext.data.Store&#39;, {
    extend: &#39;Ext.data.AbstractStore&#39;,
    
    requires: [&#39;Ext.ModelMgr&#39;],
    uses: [&#39;Ext.data.MemoryProxy&#39;],
    
    <a name="cfg-Ext.data.Store-remoteSort"></a>/**
     * @cfg {Boolean} remoteSort
     * True to defer any sorting operation to the server. If false, sorting is done locally on the client. Defaults to &lt;tt&gt;false&lt;/tt&gt;.
     */
    remoteSort: false,

    <a name="cfg-Ext.data.Store-remoteFilter"></a>/**
     * @cfg {Boolean} remoteFilter
     * True to defer any filtering operation to the server. If false, filtering is done locally on the client. Defaults to &lt;tt&gt;false&lt;/tt&gt;.
     */
    remoteFilter: false,

    <a name="cfg-Ext.data.Store-proxy"></a>/**
     * @cfg {String/Ext.data.Proxy/Object} proxy The Proxy to use for this Store. This can be either a string, a config
     * object or a Proxy instance - see {@link #setProxy} for details.
     */

    <a name="cfg-Ext.data.Store-data"></a>/**
     * @cfg {Array} data Optional array of Model instances or data objects to load locally. See &quot;Inline data&quot; above for details.
     */

    <a name="prop-Ext.data.Store-groupField"></a>/**
     * The (optional) field by which to group data in the store. Internally, grouping is very similar to sorting - the
     * groupField and {@link #groupDir} are injected as the first sorter (see {@link #sort}). Stores support a single
     * level of grouping, and groups can be fetched via the {@link #getGroups} method.
     * @property groupField
     * @type String
     */
    groupField: undefined,

    <a name="prop-Ext.data.Store-groupDir"></a>/**
     * The direction in which sorting should be applied when grouping. Defaults to &quot;ASC&quot; - the other supported value is &quot;DESC&quot;
     * @property groupDir
     * @type String
     */
    groupDir: &quot;ASC&quot;,

    <a name="prop-Ext.data.Store-pageSize"></a>/**
     * The number of records considered to form a &#39;page&#39;. This is used to power the built-in
     * paging using the nextPage and previousPage functions. Defaults to 25.
     * @property pageSize
     * @type Number
     */
    pageSize: 25,

    <a name="prop-Ext.data.Store-currentPage"></a>/**
     * The page that the Store has most recently loaded (see {@link #loadPage})
     * @property currentPage
     * @type Number
     */
    currentPage: 1,
    
    <a name="cfg-Ext.data.Store-clearOnPageLoad"></a>/**
     * @cfg {Boolean} clearOnPageLoad True to empty the store when loading another page via {@link #loadPage}, 
     * {@link #nextPage} or {@link #previousPage} (defaults to true). Setting to false keeps existing records, allowing
     * large data sets to be loaded one page at a time but rendered all together.
     */
    clearOnPageLoad: true,

    /**
     * True if a model was created implicitly for this Store. This happens if a fields array is passed to the Store&#39;s constructor
     * instead of a model constructor or name.
     * @property implicitModel
     * @type Boolean
     * @private
     */
    implicitModel: false,

    /**
     * True if the Store is currently loading via its Proxy
     * @property loading
     * @type Boolean
     * @private
     */
    loading: false,
    
    <a name="cfg-Ext.data.Store-sortOnFilter"></a>/**
     * @cfg {Boolean} sortOnFilter For local filtering only, causes {@link #sort} to be called whenever {@link #filter} is called,
     * causing the sorters to be reapplied after filtering. Defaults to true
     */
    sortOnFilter: true,

    isStore: true,

    //documented above
    constructor: function(config) {
        config = config || {};
        
        var me = this,
            proxy,
            data;
        
        <a name="prop-Ext.data.Store-data"></a>/**
         * The MixedCollection that holds this store&#39;s local cache of records
         * @property data
         * @type Ext.util.MixedCollection
         */
        me.data = new Ext.util.MixedCollection(false, function(record) {
            return record.internalId;
        });

        if (config.data) {
            me.inlineData = config.data;
            delete config.data;
        }

        Ext.data.Store.superclass.constructor.call(me, config);
        
        proxy = me.proxy;
        data  = me.inlineData;
            
        if (data) {
            if (proxy instanceof Ext.data.MemoryProxy) {
                proxy.data = data;
                me.read();
            } else {
                me.add.apply(me, data);
            }
            
            me.sort();
            delete me.inlineData;
        } else if (me.autoLoad) {
            // debugger;
            Ext.defer(me.load, 10, me, [typeof me.autoLoad === &#39;object&#39; ? me.autoLoad : undefined]);
            // Remove the defer call, we may need reinstate this at some point, but currently it&#39;s not obvious why it&#39;s here.
            // this.load(typeof this.autoLoad == &#39;object&#39; ? this.autoLoad : undefined);
        }
    },

    <a name="method-Ext.data.Store-getGroups"></a>/**
     * Returns an object containing the result of applying grouping to the records in this store. See {@link #groupField},
     * {@link #groupDir} and {@link #getGroupString}. Example for a store containing records with a color field:
<br><span style="display: none">**/</span>var myStore = new Ext.data.Store({
    groupField: &#39;color&#39;,
    groupDir  : &#39;DESC&#39;
});

myStore.getGroups(); //returns:
[
    {
        name: &#39;yellow&#39;,
        children: [
            //all records where the color field is &#39;yellow&#39;
        ]
    },
    {
        name: &#39;red&#39;,
        children: [
            //all records where the color field is &#39;red&#39;
        ]
    }
]
<br><span style="display: none">/**</span>     * @return {Array} The grouped data
     */
    getGroups: function() {
        var records  = this.data.items,
            length   = records.length,
            groups   = [],
            pointers = {},
            record, groupStr, group, i;

        for (i = 0; i &lt; length; i++) {
            record = records[i];
            groupStr = this.getGroupString(record);
            group = pointers[groupStr];

            if (group === undefined) {
                group = {
                    name: groupStr,
                    children: []
                };

                groups.push(group);
                pointers[groupStr] = group;
            }

            group.children.push(record);
        }
        
        return groups;
    },
    
    /**
     * @private
     * For a given set of records and a Grouper, returns an array of arrays - each of which is the set of records
     * matching a certain group.
     */
    getGroupsForGrouper: function(records, grouper) {
        var length = records.length,
            groups = [],
            oldValue, newValue, record, group, i;
        
        for (i = 0; i &lt; length; i++) {
            record   = records[i];
            newValue = grouper.getGroupString(record);
            
            if (newValue !== oldValue) {
                group = {
                    name   : newValue,
                    grouper: grouper,
                    records: []
                };
                groups.push(group);
            }
            
            group.records.push(record);
            
            oldValue = newValue;
        }
        
        return groups;
    },
    
    /**
     * @private
     * This is used recursively to gather the records into the configured Groupers. The data MUST have been sorted for
     * this to work properly (see {@link #getGroupData} and {@link #getGroupsForGrouper}) Most of the work is done by
     * {@link #getGroupsForGrouper} - this function largely just handles the recursion.
     * @param {Array} records The set or subset of records to group
     * @param {Number} grouperIndex The grouper index to retrieve
     * @return {Array} The grouped records
     */
    getGroupsForGrouperIndex: function(records, grouperIndex) {
        var me       = this,
            groupers = me.groupers,
            grouper  = groupers.getAt(grouperIndex),
            groups   = me.getGroupsForGrouper(records, grouper),
            length   = groups.length,
            i;
        
        if (grouperIndex + 1 &lt; groupers.length) {
            for (i = 0; i &lt; length; i++) {
                groups[i].children = me.getGroupsForGrouperIndex(groups[i].records, grouperIndex + 1);
            }
        }
        
        for (i = 0; i &lt; length; i++) {
            groups[i].depth = grouperIndex;
        }
        
        return groups;
    },

    /**
     * @private
     * &lt;p&gt;Returns records grouped by the configured {@link #groupers grouper} configuration. Sample return value (in
     * this case grouping by genre and then author in a fictional books dataset):&lt;/p&gt;
<br><span style="display: none">**/</span>[
    {
        name: &#39;Fantasy&#39;,
        depth: 0,
        records: [
            //book1, book2, book3, book4
        ],
        children: [
            {
                name: &#39;Rowling&#39;,
                depth: 1,
                records: [
                    //book1, book2
                ]
            },
            {
                name: &#39;Tolkein&#39;,
                depth: 1,
                records: [
                    //book3, book4
                ]
            }
        ]
    }
]
<br><span style="display: none">/**</span>     * @param {Boolean} sort True to call {@link #sort} before finding groups. Sorting is required to make grouping 
     * function correctly so this should only be set to false if the Store is known to already be sorted correctly
     * (defaults to true)
     * @return {Array} The group data
     */
    getGroupData: function(sort) {
        var me = this;
        if (sort !== false) {
            me.sort();
        }
        
        return me.getGroupsForGrouperIndex(me.data.items, 0);
    },

    <a name="method-Ext.data.Store-getGroupString"></a>/**
     * &lt;p&gt;Returns the string to group on for a given model instance. The default implementation of this method returns 
     * the model&#39;s {@link #groupField}, but this can be overridden to group by an arbitrary string. For example, to 
     * group by the first letter of a model&#39;s &#39;name&#39; field, use the following code:&lt;/p&gt;
<br><span style="display: none">**/</span>new Ext.data.Store({
    groupDir: &#39;ASC&#39;,
    getGroupString: function(instance) {
        return instance.get(&#39;name&#39;)[0];
    }
});
<br><span style="display: none">/**</span>     * @param {Ext.data.Model} instance The model instance
     * @return {String} The string to compare when forming groups
     */
    getGroupString: function(instance) {
        return instance.get(this.groupField);
    },
    
    <a name="method-Ext.data.Store-first"></a>/**
     * Convenience function for getting the first model instance in the store
     * @return {Ext.data.Model/undefined} The first model instance in the store, or undefined
     */
    first: function() {
        return this.data.first();
    },
    
    <a name="method-Ext.data.Store-last"></a>/**
     * Convenience function for getting the last model instance in the store
     * @return {Ext.data.Model/undefined} The last model instance in the store, or undefined
     */
    last: function() {
        return this.data.last();
    },

    <a name="method-Ext.data.Store-insert"></a>/**
     * Inserts Model instances into the Store at the given index and fires the {@link #add} event.
     * See also &lt;code&gt;{@link #add}&lt;/code&gt;.
     * @param {Number} index The start index at which to insert the passed Records.
     * @param {Ext.data.Model[]} records An Array of Ext.data.Model objects to add to the cache.
     */
    insert : function(index, records) {
        var me = this,
            i, record, len;

        records = [].concat(records);
        for (i = 0, len = records.length; i &lt; len; i++) {
            record = me.createModel(records[i]);
            record.set(me.modelDefaults);

            me.data.insert(index + i, record);
            record.join(me);
        }

        if (me.snapshot) {
            me.snapshot.addAll(records);
        }

        me.fireEvent(&#39;add&#39;, me, records, index);
        me.fireEvent(&#39;datachanged&#39;, me);
    },

    <a name="method-Ext.data.Store-add"></a>/**
     * Adds Model instances to the Store by instantiating them based on a JavaScript object. When adding already-
     * instantiated Models, use {@link #insert} instead. The instances will be added at the end of the existing collection.
     * This method accepts either a single argument array of Model instances or any number of model instance arguments.
     * Sample usage:
     * 
<br><span style="display: none">**/</span>myStore.add({some: &#39;data&#39;}, {some: &#39;other data&#39;});
<br><span style="display: none">/**</span>     * 
     * @param {Object} data The data for each model
     * @return {Array} The array of newly created model instances
     */
    add: function(records) {
        //accept both a single-argument array of records, or any number of record arguments
        if (!Ext.isArray(records)) {
            records = Array.prototype.slice.apply(arguments);
        }
        
        var me     = this,
            i      = 0,
            length = records.length,
            record;

        for (; i &lt; length; i++) {
            record = me.createModel(records[i]);

            if (record.phantom === false) {
                record.needsAdd = true;
            }
            
            records[i] = record;
        }

        me.insert(me.data.length, records);

        return records;
    },

    /**
     * Converts a literal to a model, if it&#39;s not a model already 
     * @private
     * @param record {Ext.data.Model/Object} The record to create
     * @return {Ext.data.Model}
     */
    createModel: function(record) {
        if (!(record instanceof Ext.data.Model)) {
            record = Ext.ModelMgr.create(record, this.model);
        }
        
        return record;
    },

    <a name="method-Ext.data.Store-each"></a>/**
     * Calls the specified function for each of the {@link Ext.data.Model Records} in the cache.
     * @param {Function} fn The function to call. The {@link Ext.data.Model Record} is passed as the first parameter.
     * Returning &lt;tt&gt;false&lt;/tt&gt; aborts and exits the iteration.
     * @param {Object} scope (optional) The scope (&lt;code&gt;this&lt;/code&gt; reference) in which the function is executed.
     * Defaults to the current {@link Ext.data.Model Record} in the iteration.
     */
    each : function(fn, scope) {
        this.data.each(fn, scope);
    },

    <a name="method-Ext.data.Store-remove"></a>/**
     * Removes the given record from the Store, firing the &#39;remove&#39; event for each instance that is removed, plus a single
     * &#39;datachanged&#39; event after removal.
     * @param {Ext.data.Model/Array} records The Ext.data.Model instance or array of instances to remove
     */
    remove: function(records) {
        if (!Ext.isArray(records)) {
            records = [records];
        }

        var me     = this,
            i      = 0,
            length = records.length,
            index, record;

        for (; i &lt; length; i++) {
            record = records[i];
            index = me.data.indexOf(record);

            if (index &gt; -1) {
                me.removed.push(record);

                if (me.snapshot) {
                    me.snapshot.remove(record);
                }

                record.unjoin(me);
                me.data.remove(record);

                me.fireEvent(&#39;remove&#39;, me, record, index);
            }
        }

        me.fireEvent(&#39;datachanged&#39;, me);
    },

    <a name="method-Ext.data.Store-removeAt"></a>/**
     * Removes the model instance at the given index
     * @param {Number} index The record index
     */
    removeAt: function(index) {
        var record = this.getAt(index);

        if (record) {
            this.remove(record);
        }
    },

    <a name="method-Ext.data.Store-load"></a>/**
     * &lt;p&gt;Loads data into the Store via the configured {@link #proxy}. This uses the Proxy to make an
     * asynchronous call to whatever storage backend the Proxy uses, automatically adding the retrieved
     * instances into the Store and calling an optional callback if required. Example usage:&lt;/p&gt;
     * 
<br><span style="display: none">**/</span>store.load({
    scope   : this,
    callback: function(records, operation, success) {
        //the {@link Ext.data.Operation operation} object contains all of the details of the load operation
        console.log(records);
    }
});
<br><span style="display: none">/**</span>     * 
     * &lt;p&gt;If the callback scope does not need to be set, a function can simply be passed:&lt;/p&gt;
     * 
<br><span style="display: none">**/</span>store.load(function(records, operation, success) {
    console.log(&#39;loaded records&#39;);
});
<br><span style="display: none">/**</span>     * 
     * @param {Object/Function} options Optional config object, passed into the Ext.data.Operation object before loading.
     */
    load: function(options) {
        var me = this;
        options = options || {};
        
        if (Ext.isFunction(options)) {
            options = {
                callback: options
            };
        }
        
        Ext.applyIf(options, {
            group : {field: me.groupField, direction: me.groupDir},
            start : (me.currentPage - 1) * me.pageSize,
            limit : me.pageSize,
            addRecords: false
        });
        
        return Ext.data.Store.superclass.load.call(me, options);
    },
    
    <a name="method-Ext.data.Store-isLoading"></a>/**
     * Returns true if the Store is currently performing a load operation
     * @return {Boolean} True if the Store is currently loading
     */
    isLoading: function() {
        return this.loading;
    },

    /**
     * @private
     * Called internally when a Proxy has completed a load request
     */
    onProxyLoad: function(operation) {
        var me         = this,
            resultSet  = operation.getResultSet(),
            records    = operation.getRecords(),
            successful = operation.wasSuccessful();
        
        if (resultSet) {
            me.totalCount = resultSet.total;
        }
        
        if (successful) {
            me.loadRecords(records, operation.addRecords);
        }
        
        me.loading = false;
        me.fireEvent(&#39;load&#39;, me, records, successful);
        
        //TODO: deprecate this event, it should always have been &#39;load&#39; instead. &#39;load&#39; is now documented, &#39;read&#39; is not.
        //People are definitely using this so can&#39;t deprecate safely until 2.x
        me.fireEvent(&#39;read&#39;, me, records, operation.wasSuccessful());

        //this is a callback that would have been passed to the &#39;read&#39; function and is optional
        Ext.callback(operation.callback, operation.scope || me, [records, operation, successful]);
    },

    /**
     * @private
     * Callback for any write Operation over the Proxy. Updates the Store&#39;s MixedCollection to reflect
     * the updates provided by the Proxy
     */
    onProxyWrite: function(operation) {
        var me       = this,
            data     = me.data,
            action   = operation.action,
            i        = 0,
            records  = operation.getRecords(),
            length   = records.length,
            successful = operation.wasSuccessful(),
            record;

        if (successful) {
            if (action === &#39;create&#39; || action === &#39;update&#39;) {
                for (; i &lt; length; i++) {
                    record = records[i];

                    record.phantom = false;
                    record.join(me);
                    data.replace(record);
                }
            }

            else if (action === &#39;destroy&#39;) {
                for (; i &lt; length; i++) {
                    record = records[i];

                    record.unjoin(me);
                    data.remove(record);
                }

                me.removed = [];
            }

            me.fireEvent(&#39;datachanged&#39;);
        }

        //this is a callback that would have been passed to the &#39;create&#39;, &#39;update&#39; or &#39;destroy&#39; function and is optional
        Ext.callback(operation.callback, operation.scope || me, [records, operation, successful]);
    },

    //inherit docs
    getNewRecords: function() {
        return this.data.filterBy(this.filterNew).items;
    },

    //inherit docs
    getUpdatedRecords: function() {
        return this.data.filterBy(this.filterDirty).items;
    },

    <a name="method-Ext.data.Store-sort"></a>/**
     * &lt;p&gt;Sorts the data in the Store by one or more of its properties. Example usage:&lt;/p&gt;
<br><span style="display: none">**/</span>//sort by a single field
myStore.sort(&#39;myField&#39;, &#39;DESC&#39;);

//sorting by multiple fields
myStore.sort([
    {
        property : &#39;age&#39;,
        direction: &#39;ASC&#39;
    },
    {
        property : &#39;name&#39;,
        direction: &#39;DESC&#39;
    }
]);
<br><span style="display: none">/**</span>     * &lt;p&gt;Internally, Store converts the passed arguments into an array of {@link Ext.util.Sorter} instances, and delegates the actual
     * sorting to its internal {@link Ext.util.MixedCollection}.&lt;/p&gt;
     * &lt;p&gt;When passing a single string argument to sort, Store maintains a ASC/DESC toggler per field, so this code:&lt;/p&gt;
<br><span style="display: none">**/</span>store.sort(&#39;myField&#39;);
store.sort(&#39;myField&#39;);
     <br><span style="display: none">/**</span>     * &lt;p&gt;Is equivalent to this code, because Store handles the toggling automatically:&lt;/p&gt;
<br><span style="display: none">**/</span>store.sort(&#39;myField&#39;, &#39;ASC&#39;);
store.sort(&#39;myField&#39;, &#39;DESC&#39;);
<br><span style="display: none">/**</span>     * @param {String|Array} sorters Either a string name of one of the fields in this Store&#39;s configured {@link Ext.data.Model Model},
     * or an Array of sorter configurations.
     * @param {String} direction The overall direction to sort the data by. Defaults to &quot;ASC&quot;.
     */
    sort: function(sorters, direction) {
        var me = this,
            property,
            sortToggle,
            toggle;
            
        if (Ext.isString(sorters)) {
            property = sorters;
            sortToggle = me.sortToggle;
            toggle = Ext.String.toggle;

            if (direction === undefined) {
                sortToggle[property] = toggle(sortToggle[property] || &quot;&quot;, &quot;ASC&quot;, &quot;DESC&quot;);
                direction = sortToggle[property];
            }

            sorters = {
                property : property,
                direction: direction
            };
        }
        
        if (arguments.length !== 0) {
            me.sorters.clear();
        }
        
        me.sorters.addAll(me.decodeSorters(sorters));

        if (me.remoteSort) {
            //the load function will pick up the new sorters and request the sorted data from the proxy
            me.load();
        } else {
            me.data.sort(me.sorters.items);

            me.fireEvent(&#39;datachanged&#39;, me);
        }
    },


    <a name="method-Ext.data.Store-filter"></a>/**
     * Filters the loaded set of records by a given set of filters.
     * @param {Mixed} filters The set of filters to apply to the data. These are stored internally on the store,
     * but the filtering itself is done on the Store&#39;s {@link Ext.util.MixedCollection MixedCollection}. See
     * MixedCollection&#39;s {@link Ext.util.MixedCollection#filter filter} method for filter syntax. Alternatively,
     * pass in a property string
     * @param {String} value Optional value to filter by (only if using a property string as the first argument)
     */
    filter: function(filters, value) {
        if (Ext.isString(filters)) {
            filters = {
                property: filters,
                value   : value
            };
        }
        
        var me      = this,
            decoded = me.decodeFilters(filters),
            i       = 0,
            length  = decoded.length;
        
        for (; i &lt; length; i++) {
            me.filters.replace(decoded[i]);
        }

        if (me.remoteFilter) {
            //the load function will pick up the new filters and request the filtered data from the proxy
            me.load();
        } else {
            <a name="prop-Ext.data.Store-snapshot"></a>/**
             * A pristine (unfiltered) collection of the records in this store. This is used to reinstate
             * records when a filter is removed or changed
             * @property snapshot
             * @type Ext.util.MixedCollection
             */
            me.snapshot = me.snapshot || me.data.clone();

            me.data = me.data.filter(me.filters.items);
            
            if (me.sortOnFilter &amp;&amp; !me.remoteSort) {
                me.sort();
            } else {
                me.fireEvent(&#39;datachanged&#39;, me);
            }
        }
    },

    <a name="method-Ext.data.Store-clearFilter"></a>/**
     * Revert to a view of the Record cache with no filtering applied.
     * @param {Boolean} suppressEvent If &lt;tt&gt;true&lt;/tt&gt; the filter is cleared silently without firing the
     * {@link #datachanged} event.
     */
    clearFilter : function(suppressEvent) {
        var me = this;
        
        me.filters.clear();
        
        if (me.isFiltered()) {
            me.data = me.snapshot.clone();
            delete me.snapshot;

            if (suppressEvent !== true) {
                me.fireEvent(&#39;datachanged&#39;, me);
            }
        }
    },

    <a name="method-Ext.data.Store-isFiltered"></a>/**
     * Returns true if this store is currently filtered
     * @return {Boolean}
     */
    isFiltered : function() {
        var snapshot = this.snapshot;
        return !!snapshot &amp;&amp; snapshot !== this.data;
    },

    <a name="method-Ext.data.Store-filterBy"></a>/**
     * Filter by a function. The specified function will be called for each
     * Record in this Store. If the function returns &lt;tt&gt;true&lt;/tt&gt; the Record is included,
     * otherwise it is filtered out.
     * @param {Function} fn The function to be called. It will be passed the following parameters:&lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;record&lt;/b&gt; : Ext.data.Model&lt;p class=&quot;sub-desc&quot;&gt;The {@link Ext.data.Model record}
     * to test for filtering. Access field values using {@link Ext.data.Model#get}.&lt;/p&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;b&gt;id&lt;/b&gt; : Object&lt;p class=&quot;sub-desc&quot;&gt;The ID of the Record passed.&lt;/p&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * @param {Object} scope (optional) The scope (&lt;code&gt;this&lt;/code&gt; reference) in which the function is executed. Defaults to this Store.
     */
    filterBy : function(fn, scope) {
        var me = this;
        
        me.snapshot = me.snapshot || me.data.clone();
        me.data = me.queryBy(fn, scope || me);
        me.fireEvent(&#39;datachanged&#39;, me);
    },

    <a name="method-Ext.data.Store-queryBy"></a>/**
     * Query the cached records in this Store using a filtering function. The specified function
     * will be called with each record in this Store. If the function returns &lt;tt&gt;true&lt;/tt&gt; the record is
     * included in the results.
     * @param {Function} fn The function to be called. It will be passed the following parameters:&lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;record&lt;/b&gt; : Ext.data.Model&lt;p class=&quot;sub-desc&quot;&gt;The {@link Ext.data.Model record}
     * to test for filtering. Access field values using {@link Ext.data.Model#get}.&lt;/p&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;b&gt;id&lt;/b&gt; : Object&lt;p class=&quot;sub-desc&quot;&gt;The ID of the Record passed.&lt;/p&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * @param {Object} scope (optional) The scope (&lt;code&gt;this&lt;/code&gt; reference) in which the function is executed. Defaults to this Store.
     * @return {MixedCollection} Returns an Ext.util.MixedCollection of the matched records
     **/
    queryBy : function(fn, scope) {
        var me   = this,
            data = me.snapshot || me.data;
        return data.filterBy(fn, scope || me);
    },
    
    <a name="method-Ext.data.Store-loadData"></a>/**
     * Loads an array of data straight into the Store
     * @param {Array} data Array of data to load. Any non-model instances will be cast into model instances first
     * @param {Boolean} append True to add the records to the existing records in the store, false to remove the old ones first
     */
    loadData: function(data, append) {
        var model  = this.model,
            length = data.length,
            i, record;

        //make sure each data element is an Ext.data.Model instance
        for (i = 0; i &lt; length; i++) {
            record = data[i];

            if (!(record instanceof Ext.data.Model)) {
                data[i] = Ext.ModelMgr.create(record, model);
            }
        }

        this.loadRecords(data, append);
    },

    <a name="method-Ext.data.Store-loadRecords"></a>/**
     * Loads an array of {@Ext.data.Model model} instances into the store, fires the datachanged event. This should only usually
     * be called internally when loading from the {@link Ext.data.Proxy Proxy}, when adding records manually use {@link #add} instead
     * @param {Array} records The array of records to load
     * @param {Boolean} add True to add these records to the existing records, false to remove the Store&#39;s existing records first
     */
    loadRecords: function(records, add) {
        var me     = this,
            i      = 0,
            length = records.length;
            
        if (!add) {
            me.data.clear();
        }
        
        me.data.addAll(records);
        
        //FIXME: this is not a good solution. Ed Spencer is totally responsible for this and should be forced to fix it immediately.
        for (; i &lt; length; i++) {
            records[i].needsAdd = false;
            records[i].join(me);
        }
        
        /*
         * this rather inelegant suspension and resumption of events is required because both the filter and sort functions
         * fire an additional datachanged event, which is not wanted. Ideally we would do this a different way. The first
         * datachanged event is fired by the call to this.add, above.
         */
        me.suspendEvents();

        if (me.filterOnLoad &amp;&amp; !me.remoteFilter) {
            me.filter();
        }

        if (me.sortOnLoad &amp;&amp; !me.remoteSort) {
            me.sort();
        }

        me.resumeEvents();
        me.fireEvent(&#39;datachanged&#39;, me, records);
    },

    // PAGING METHODS

    <a name="method-Ext.data.Store-loadPage"></a>/**
     * Loads a given &#39;page&#39; of data by setting the start and limit values appropriately. Internally this just causes a normal
     * load operation, passing in calculated &#39;start&#39; and &#39;limit&#39; params
     * @param {Number} page The number of the page to load
     */
    loadPage: function(page) {
        var me = this;
        
        me.currentPage = page;

        me.read({
            page : page,
            start: (page - 1) * me.pageSize,
            limit: me.pageSize,
            addRecords: !me.clearOnPageLoad
        });
    },

    <a name="method-Ext.data.Store-nextPage"></a>/**
     * Loads the next &#39;page&#39; in the current data set
     */
    nextPage: function() {
        this.loadPage(this.currentPage + 1);
    },

    <a name="method-Ext.data.Store-previousPage"></a>/**
     * Loads the previous &#39;page&#39; in the current data set
     */
    previousPage: function() {
        this.loadPage(this.currentPage - 1);
    },

    // private
    clearData: function(){
        this.data.each(function(record) {
            record.unjoin();
        });

        this.data.clear();
    },

    <a name="method-Ext.data.Store-find"></a>/**
     * Finds the index of the first matching Record in this store by a specific field value.
     * @param {String} fieldName The name of the Record field to test.
     * @param {String/RegExp} value Either a string that the field value
     * should begin with, or a RegExp to test against the field.
     * @param {Number} startIndex (optional) The index to start searching at
     * @param {Boolean} anyMatch (optional) True to match any part of the string, not just the beginning
     * @param {Boolean} caseSensitive (optional) True for case sensitive comparison
     * @param {Boolean} exactMatch True to force exact match (^ and $ characters added to the regex). Defaults to false. 
     * @return {Number} The matched index or -1
     */
    find : function(property, value, start, anyMatch, caseSensitive, exactMatch) {
        var fn = this.createFilterFn(property, value, anyMatch, caseSensitive, exactMatch);
        return fn ? this.data.findIndexBy(fn, null, start) : -1;
    },

    <a name="method-Ext.data.Store-findRecord"></a>/**
     * Finds the first matching Record in this store by a specific field value.
     * @param {String} fieldName The name of the Record field to test.
     * @param {String/RegExp} value Either a string that the field value
     * should begin with, or a RegExp to test against the field.
     * @param {Number} startIndex (optional) The index to start searching at
     * @param {Boolean} anyMatch (optional) True to match any part of the string, not just the beginning
     * @param {Boolean} caseSensitive (optional) True for case sensitive comparison
     * @param {Boolean} exactMatch True to force exact match (^ and $ characters added to the regex). Defaults to false.
     * @return {Ext.data.Model} The matched record or null
     */
    findRecord : function() {
        var me     = this,
            index = me.find.apply(me, arguments);
        return index !== -1 ? me.getAt(index) : null;
    },

    /**
     * @private
     * Returns a filter function used to test a the given property&#39;s value. Defers most of the work to
     * Ext.util.MixedCollection&#39;s createValueMatcher function
     * @param {String} property The property to create the filter function for
     * @param {String/RegExp} value The string/regex to compare the property value to
     * @param {Boolean} anyMatch True if we don&#39;t care if the filter value is not the full value (defaults to false)
     * @param {Boolean} caseSensitive True to create a case-sensitive regex (defaults to false)
     * @param {Boolean} exactMatch True to force exact match (^ and $ characters added to the regex). Defaults to false. 
     * Ignored if anyMatch is true.
     */
    createFilterFn : function(property, value, anyMatch, caseSensitive, exactMatch) {
        if(Ext.isEmpty(value)){
            return false;
        }
        value = this.data.createValueMatcher(value, anyMatch, caseSensitive, exactMatch);
        return function(r) {
            return value.test(r.data[property]);
        };
    },

    <a name="method-Ext.data.Store-findExact"></a>/**
     * Finds the index of the first matching Record in this store by a specific field value.
     * @param {String} fieldName The name of the Record field to test.
     * @param {Mixed} value The value to match the field against.
     * @param {Number} startIndex (optional) The index to start searching at
     * @return {Number} The matched index or -1
     */
    findExact: function(property, value, start) {
        return this.data.findIndexBy(function(rec){
            return rec.get(property) === value;
        }, this, start);
    },

    <a name="method-Ext.data.Store-findBy"></a>/**
     * Find the index of the first matching Record in this Store by a function.
     * If the function returns &lt;tt&gt;true&lt;/tt&gt; it is considered a match.
     * @param {Function} fn The function to be called. It will be passed the following parameters:&lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;record&lt;/b&gt; : Ext.data.Model&lt;p class=&quot;sub-desc&quot;&gt;The {@link Ext.data.Model record}
     * to test for filtering. Access field values using {@link Ext.data.Model#get}.&lt;/p&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;b&gt;id&lt;/b&gt; : Object&lt;p class=&quot;sub-desc&quot;&gt;The ID of the Record passed.&lt;/p&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * @param {Object} scope (optional) The scope (&lt;code&gt;this&lt;/code&gt; reference) in which the function is executed. Defaults to this Store.
     * @param {Number} startIndex (optional) The index to start searching at
     * @return {Number} The matched index or -1
     */
    findBy : function(fn, scope, start) {
        return this.data.findIndexBy(fn, scope, start);
    },

    <a name="method-Ext.data.Store-collect"></a>/**
     * Collects unique values for a particular dataIndex from this store.
     * @param {String} dataIndex The property to collect
     * @param {Boolean} allowNull (optional) Pass true to allow null, undefined or empty string values
     * @param {Boolean} bypassFilter (optional) Pass true to collect from all records, even ones which are filtered
     * @return {Array} An array of the unique values
     **/
    collect : function(dataIndex, allowNull, bypassFilter) {
        var me   = this,
            data = (bypassFilter === true &amp;&amp; me.snapshot) ? me.snapshot : me.data;

        return data.collect(dataIndex, &#39;data&#39;, allowNull);
    },

    <a name="method-Ext.data.Store-sum"></a>/**
     * Sums the value of &lt;tt&gt;property&lt;/tt&gt; for each {@link Ext.data.Model record} between &lt;tt&gt;start&lt;/tt&gt;
     * and &lt;tt&gt;end&lt;/tt&gt; and returns the result.
     * @param {String} property A field in each record
     * @param {Number} start (optional) The record index to start at (defaults to &lt;tt&gt;0&lt;/tt&gt;)
     * @param {Number} end (optional) The last record index to include (defaults to length - 1)
     * @return {Number} The sum
     */
    sum : function(property, start, end) {
        return this.data.sum(property, &#39;data&#39;, start, end);
    },

    <a name="method-Ext.data.Store-getCount"></a>/**
     * Gets the number of cached records.
     * &lt;p&gt;If using paging, this may not be the total size of the dataset. If the data object
     * used by the Reader contains the dataset size, then the {@link #getTotalCount} function returns
     * the dataset size.  &lt;b&gt;Note&lt;/b&gt;: see the Important note in {@link #load}.&lt;/p&gt;
     * @return {Number} The number of Records in the Store&#39;s cache.
     */
    getCount : function() {
        return this.data.length || 0;
    },
    
    <a name="method-Ext.data.Store-getTotalCount"></a>/**
     * Returns the total number of {@link Ext.data.Model Model} instances that the {@link Ext.data.Proxy Proxy} 
     * indicates exist. This will usually differ from {@link #getCount} when using paging - getCount returns the 
     * number of records loaded into the Store at the moment, getTotalCount returns the number of records that 
     * could be loaded into the Store if the Store contained all data
     * @return {Number} The total number of Model instances available via the Proxy
     */
    getTotalCount: function() {
        return this.totalCount;
    },

    <a name="method-Ext.data.Store-getAt"></a>/**
     * Get the Record at the specified index.
     * @param {Number} index The index of the Record to find.
     * @return {Ext.data.Model} The Record at the passed index. Returns undefined if not found.
     */
    getAt : function(index) {
        return this.data.getAt(index);
    },

    <a name="method-Ext.data.Store-getRange"></a>/**
     * Returns a range of Records between specified indices.
     * @param {Number} startIndex (optional) The starting index (defaults to 0)
     * @param {Number} endIndex (optional) The ending index (defaults to the last Record in the Store)
     * @return {Ext.data.Model[]} An array of Records
     */
    getRange : function(start, end) {
        return this.data.getRange(start, end);
    },

    <a name="method-Ext.data.Store-getById"></a>/**
     * Get the Record with the specified id.
     * @param {String} id The id of the Record to find.
     * @return {Ext.data.Model} The Record with the passed id. Returns undefined if not found.
     */
    getById : function(id) {
        return (this.snapshot || this.data).findBy(function(record) {
            return record.getId() === id;
        });
    },

    <a name="method-Ext.data.Store-indexOf"></a>/**
     * Get the index within the cache of the passed Record.
     * @param {Ext.data.Model} record The Ext.data.Model object to find.
     * @return {Number} The index of the passed Record. Returns -1 if not found.
     */
    indexOf : function(record) {
        return this.data.indexOf(record);
    },

    <a name="method-Ext.data.Store-indexOfId"></a>/**
     * Get the index within the cache of the Record with the passed id.
     * @param {String} id The id of the Record to find.
     * @return {Number} The index of the Record. Returns -1 if not found.
     */
    indexOfId : function(id) {
        return this.data.indexOfKey(id);
    },

    removeAll: function(silent) {
        var me    = this,
            items = [];
            
        me.each(function(rec){
            items.push(rec);
        });
        me.clearData();
        if(me.snapshot){
            me.snapshot.clear();
        }
        //if(this.pruneModifiedRecords){
        //    this.modified = [];
        //}
        if (silent !== true) {
            me.fireEvent(&#39;clear&#39;, me, items);
        }
    }
});
</pre></pre></body></html>