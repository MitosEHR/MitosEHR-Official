<!DOCTYPE html><html><head><title>Sencha Documentation Project</title><link rel="stylesheet" href="../reset.css" type="text/css"><link rel="stylesheet" href="../prettify.css" type="text/css"><link rel="stylesheet" href="http://localhost:3000/new/css/prettify_sa.css" type="text/css"><script type="text/javascript" src="../prettify.js"></script></head><body onload="prettyPrint()"><pre class="prettyprint"><pre><a name="cls-Ext.button.Button"></a>/**
 * @class Ext.button.Button
 * @extends Ext.Component
 * Simple Button class
 * @cfg {String} text The button text to be used as innerHTML (html tags are accepted)
 * @cfg {String} icon The path to an image to display in the button (the image will be set as the background-image
 * CSS property of the button by default, so if you want a mixed icon/text button, set cls:&#39;x-btn-text-icon&#39;)
 * @cfg {Function} handler A function called when the button is clicked (can be used instead of click event).
 * The handler is passed the following parameters:&lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;b&lt;/code&gt; : Button&lt;div class=&quot;sub-desc&quot;&gt;This Button.&lt;/div&gt;&lt;/li&gt;
 * &lt;li&gt;&lt;code&gt;e&lt;/code&gt; : EventObject&lt;div class=&quot;sub-desc&quot;&gt;The click event.&lt;/div&gt;&lt;/li&gt;
 * &lt;/ul&gt;&lt;/div&gt;
 * @cfg {Number} minWidth The minimum width for this button (used to give a set of buttons a common width).
 * See also {@link Ext.panel.Panel}.&lt;tt&gt;{@link Ext.panel.Panel#minButtonWidth minButtonWidth}&lt;/tt&gt;.
 * @cfg {String/Object} tooltip The tooltip for the button - can be a string to be used as innerHTML (html tags are accepted) or QuickTips config object
 * @cfg {Boolean} hidden True to start hidden (defaults to false)
 * @cfg {Boolean} disabled True to start disabled (defaults to false)
 * @cfg {Boolean} pressed True to start pressed (only if enableToggle = true)
 * @cfg {String} toggleGroup The group this toggle button is a member of (only 1 per group can be pressed)
 * @cfg {Boolean/Object} repeat True to repeat fire the click event while the mouse is down. This can also be
 * a {@link Ext.util.ClickRepeater ClickRepeater} config object (defaults to false).
 * @constructor
 * Create a new button
 * @param {Object} config The config object
 * @xtype button
 */

Ext.define(&#39;Ext.button.Button&#39;, {

    /* Begin Definitions */

    alias: &#39;widget.button&#39;,

    extend: &#39;Ext.Component&#39;,

    requires: [
        &#39;Ext.menu.MenuManager&#39;,
        &#39;Ext.util.ClickRepeater&#39;,
        &#39;Ext.layout.component.Button&#39;,
        &#39;Ext.util.TextMetrics&#39;
    ],
    
    alternateClassName: &#39;Ext.Button&#39;,

    /* End Definitions */

    isButton: true,
    componentLayout: &#39;button&#39;,
    
    /**
     * Read-only. True if this button is hidden
     * @type Boolean
     */
    hidden: false,
    /**
     * Read-only. True if this button is disabled
     * @type Boolean
     */
    disabled: false,
    /**
     * Read-only. True if this button is pressed (only if enableToggle = true)
     * @type Boolean
     */
    pressed: false,

    /**
     * @cfg {Number} tabIndex Set a DOM tabIndex for this button (defaults to undefined)
     */

    /**
     * @cfg {Boolean} allowDepress
     * False to not allow a pressed Button to be depressed (defaults to undefined). Only valid when {@link #enableToggle} is true.
     */

    /**
     * @cfg {Boolean} enableToggle
     * True to enable pressed/not pressed toggling (defaults to false)
     */
    enableToggle: false,

    /**
     * @cfg {Function} toggleHandler
     * Function called when a Button with {@link #enableToggle} set to true is clicked. Two arguments are passed:&lt;ul class=&quot;mdetail-params&quot;&gt;
     * &lt;li&gt;&lt;b&gt;button&lt;/b&gt; : Ext.button.Button&lt;div class=&quot;sub-desc&quot;&gt;this Button object&lt;/div&gt;&lt;/li&gt;
     * &lt;li&gt;&lt;b&gt;state&lt;/b&gt; : Boolean&lt;div class=&quot;sub-desc&quot;&gt;The next state of the Button, true means pressed.&lt;/div&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     */

    /**
     * @cfg {Mixed} menu
     * Standard menu attribute consisting of a reference to a menu object, a menu id or a menu config blob (defaults to undefined).
     */

    /**
     * @cfg {String} menuAlign
     * The position to align the menu to (see {@link Ext.core.Element#alignTo} for more details, defaults to &#39;tl-bl?&#39;).
     */
    menuAlign: &#39;tl-bl?&#39;,

    /**
     * @cfg {String} overflowText If used in a {@link Ext.toolbar.Toolbar Toolbar}, the
     * text to be used if this item is shown in the overflow menu. See also
     * {@link Ext.toolbar.Item}.&lt;code&gt;{@link Ext.toolbar.Item#overflowText overflowText}&lt;/code&gt;.
     */

    /**
     * @cfg {String} iconCls
     * A css class which sets a background image to be used as the icon for this button
     */

    /**
     * @cfg {String} type
     * submit, reset or button - defaults to &#39;button&#39;
     */
    type: &#39;button&#39;,

    /**
     * @cfg {String} clickEvent
     * The DOM event that will fire the handler of the button. This can be any valid event name (dblclick, contextmenu).
     * Defaults to &lt;tt&gt;&#39;click&#39;&lt;/tt&gt;.
     */
    clickEvent: &#39;click&#39;,

    /**
     * @cfg {Boolean} handleMouseEvents
     * False to disable visual cues on mouseover, mouseout and mousedown (defaults to true)
     */
    handleMouseEvents: true,

    /**
     * @cfg {String} tooltipType
     * The type of tooltip to use. Either &#39;qtip&#39; (default) for QuickTips or &#39;title&#39; for title attribute.
     */
    tooltipType: &#39;qtip&#39;,

    /**
     * @cfg {String} baseCls
     * The base CSS class to add to all buttons. (Defaults to &#39;x-btn&#39;)
     */
    baseCls: Ext.baseCSSPrefix + &#39;btn&#39;,

    /**
     * @cfg {String} pressedCls
     * The CSS class to add to a button when it is in the pressed state. (Defaults to &#39;x-btn-default-small-pressed&#39;)
     */
     
    /**
     * @cfg {String} overCls
     * The CSS class to add to a button when it is in the over (hovered) state. (Defaults to &#39;x-btn-default-small-over&#39;)
     */

    /**
     * @cfg {String} focusCls
     * The CSS class to add to a button when it is in the focussed state. (Defaults to &#39;x-btn-default-small-focus&#39;)
     */

    ariaRole: &#39;button&#39;,

    // inherited
    renderTpl:
        &#39;&lt;em class=&quot;{splitCls}&quot;&gt;&#39; +
            &#39;&lt;button type=&quot;{type}&quot;&#39; +
                &#39;&lt;tpl if=&quot;tabIndex&quot;&gt; tabIndex=&quot;{tabIndex}&quot;&lt;/tpl&gt; role=&quot;button&quot;&gt;{text}&#39; +
            &#39;&lt;/button&gt;&#39; +
        &#39;&lt;/em&gt;&#39;,

    /**
     * @cfg {String} scale
     * &lt;p&gt;(Optional) The size of the Button. Three values are allowed:&lt;/p&gt;
     * &lt;ul class=&quot;mdetail-params&quot;&gt;
     * &lt;li&gt;&#39;small&#39;&lt;div class=&quot;sub-desc&quot;&gt;Results in the button element being 16px high.&lt;/div&gt;&lt;/li&gt;
     * &lt;li&gt;&#39;medium&#39;&lt;div class=&quot;sub-desc&quot;&gt;Results in the button element being 24px high.&lt;/div&gt;&lt;/li&gt;
     * &lt;li&gt;&#39;large&#39;&lt;div class=&quot;sub-desc&quot;&gt;Results in the button element being 32px high.&lt;/div&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;Defaults to &lt;b&gt;&lt;tt&gt;&#39;small&#39;&lt;/tt&gt;&lt;/b&gt;.&lt;/p&gt;
     */
    scale: &#39;small&#39;,

    /**
     * @cfg {String} ui
     * &lt;p&gt;(Optional) The UI specified for the button.&lt;/p&gt;
     * &lt;p&gt;Defaults to &lt;b&gt;&lt;tt&gt;&#39;default&#39;&lt;/tt&gt;&lt;/b&gt;.&lt;/p&gt;
     */
    ui: &#39;default&#39;,

    /**
     * @cfg {Object} scope The scope (&lt;tt&gt;&lt;b&gt;this&lt;/b&gt;&lt;/tt&gt; reference) in which the
     * &lt;code&gt;{@link #handler}&lt;/code&gt; and &lt;code&gt;{@link #toggleHandler}&lt;/code&gt; is
     * executed. Defaults to this Button.
     */

    /**
     * @cfg {String} iconAlign
     * &lt;p&gt;(Optional) The side of the Button box to render the icon. Four values are allowed:&lt;/p&gt;
     * &lt;ul class=&quot;mdetail-params&quot;&gt;
     * &lt;li&gt;&#39;top&#39;&lt;div class=&quot;sub-desc&quot;&gt;&lt;/div&gt;&lt;/li&gt;
     * &lt;li&gt;&#39;right&#39;&lt;div class=&quot;sub-desc&quot;&gt;&lt;/div&gt;&lt;/li&gt;
     * &lt;li&gt;&#39;bottom&#39;&lt;div class=&quot;sub-desc&quot;&gt;&lt;/div&gt;&lt;/li&gt;
     * &lt;li&gt;&#39;left&#39;&lt;div class=&quot;sub-desc&quot;&gt;&lt;/div&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;Defaults to &lt;b&gt;&lt;tt&gt;&#39;left&#39;&lt;/tt&gt;&lt;/b&gt;.&lt;/p&gt;
     */
    iconAlign: &#39;left&#39;,

    /**
     * @cfg {String} arrowAlign
     * &lt;p&gt;(Optional) The side of the Button box to render the arrow if the button has an associated {@link #menu}.
     * Two values are allowed:&lt;/p&gt;
     * &lt;ul class=&quot;mdetail-params&quot;&gt;
     * &lt;li&gt;&#39;right&#39;&lt;div class=&quot;sub-desc&quot;&gt;&lt;/div&gt;&lt;/li&gt;
     * &lt;li&gt;&#39;bottom&#39;&lt;div class=&quot;sub-desc&quot;&gt;&lt;/div&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;Defaults to &lt;b&gt;&lt;tt&gt;&#39;right&#39;&lt;/tt&gt;&lt;/b&gt;.&lt;/p&gt;
     */
    arrowAlign: &#39;right&#39;,
    
    /**
     * @cfg {String} arrowCls
     * &lt;p&gt;(Optional) The className used for the inner arrow element if the button has a menu.&lt;/p&gt;
     */
    arrowCls: &#39;arrow&#39;,

    /**
     * @cfg {Ext.Template} template (Optional)
     * &lt;p&gt;A {@link Ext.Template Template} used to create the Button&#39;s DOM structure.&lt;/p&gt;
     * Instances, or subclasses which need a different DOM structure may provide a different
     * template layout in conjunction with an implementation of {@link #getTemplateArgs}.
     * @type Ext.Template
     * @property template
     */
    /**
     * @cfg {String} cls
     * A CSS class string to apply to the button&#39;s main element.
     */
    /**
     * @property menu
     * @type Menu
     * The {@link Ext.menu.Menu Menu} object associated with this Button when configured with the {@link #menu} config option.
     */
    /**
     * @cfg {Boolean} autoWidth
     * By default, if a width is not specified the button will attempt to stretch horizontally to fit its content.
     * If the button is being managed by a width sizing layout (hbox, fit, anchor), set this to false to prevent
     * the button from doing this automatic sizing.
     * Defaults to &lt;tt&gt;undefined&lt;/tt&gt;.
     */

    initComponent: function() {
        var me = this;
        me.callParent(arguments);

        me.addEvents(
            /**
             * @event click
             * Fires when this button is clicked
             * @param {Button} this
             * @param {EventObject} e The click event
             */
            &#39;click&#39;,
            /**
             * @event toggle
             * Fires when the &#39;pressed&#39; state of this button changes (only if enableToggle = true)
             * @param {Button} this
             * @param {Boolean} pressed
             */
            &#39;toggle&#39;,
            /**
             * @event mouseover
             * Fires when the mouse hovers over the button
             * @param {Button} this
             * @param {Event} e The event object
             */
            &#39;mouseover&#39;,
            /**
             * @event mouseout
             * Fires when the mouse exits the button
             * @param {Button} this
             * @param {Event} e The event object
             */
            &#39;mouseout&#39;,
            /**
             * @event menushow
             * If this button has a menu, this event fires when it is shown
             * @param {Button} this
             * @param {Menu} menu
             */
            &#39;menushow&#39;,
            /**
             * @event menuhide
             * If this button has a menu, this event fires when it is hidden
             * @param {Button} this
             * @param {Menu} menu
             */
            &#39;menuhide&#39;,
            /**
             * @event menutriggerover
             * If this button has a menu, this event fires when the mouse enters the menu triggering element
             * @param {Button} this
             * @param {Menu} menu
             * @param {EventObject} e
             */
            &#39;menutriggerover&#39;,
            /**
             * @event menutriggerout
             * If this button has a menu, this event fires when the mouse leaves the menu triggering element
             * @param {Button} this
             * @param {Menu} menu
             * @param {EventObject} e
             */
            &#39;menutriggerout&#39;
        );

        if (me.menu) {
            // Flag that we&#39;ll have a splitCls
            me.split = true;

            // retrieve menu by id or instantiate instance if needed
            me.menu = Ext.menu.MenuManager.get(me.menu);
        }

        if (Ext.isString(me.toggleGroup)) {
            me.enableToggle = true;
        }
        // 
        // me.baseCls += (&#39;-&#39; + me.ui + &#39;-&#39; + me.scale);

    },

    initAria: function() {
        this.callParent();
        var actionEl = this.getActionEl();
        if (this.menu) {
            actionEl.dom.setAttribute(&#39;aria-haspopup&#39;, true);
        }
    },

    getActionEl: function() {
        return this.btnEl;
    },

    getFocusEl: function() {
        return this.btnEl;
    },

    // private
    setButtonCls: function() {
        var me = this,
            el = me.el;

        if (me.useSetClass) {
            if (!Ext.isEmpty(me.oldCls)) {
                el.removeCls([me.oldCls, me.baseCls + &#39;-pressed&#39;, me.pressedCls]);
            }
            me.oldCls = (me.iconCls || me.icon) ? (me.text ? me.baseCls + &#39;-text-icon &#39; + me.baseCls + &#39;-text-icon-&#39; + me.iconAlign :  me.baseCls + &#39;-icon&#39;) : &#39;&#39;;
            el.addCls([me.oldCls, me.pressed ? (me.baseCls + &#39;-pressed &#39; + me.pressedCls) : null]);
        }
    },

    // private
    onRender: function(ct, position) {
        // classNames for the button
        var me = this,
            repeater, btn,
            btnIconCls;

        me.cls = (me.cls || &#39;&#39;) + &#39; &#39; + me.baseCls + &#39;-&#39; + me.ui;

        if (me.scale) {
            me.ui += &#39;-&#39; + me.scale;
            me.addCls(me.baseCls + &#39;-&#39; + me.scale);
        }

        me.disabledCls = me.disabledCls + &#39; &#39; + me.baseCls + &#39;-&#39; + me.ui + &#39;-disabled&#39;;
        me.overCls = me.baseCls + &#39;-&#39; + me.ui + &#39;-over&#39;;
        me.pressedCls = me.baseCls + &#39;-&#39; + me.ui + &#39;-pressed&#39;;
        me.focusCls = me.baseCls + &#39;-&#39; + me.ui + &#39;-focus&#39;;

        // only add the icon class if the button has an icon
        if (me.iconCls || me.icon) {
            if (me.text) {
                btnIconCls  = me.baseCls + &#39;-&#39; + me.ui + &#39;-icon-text-&#39; + me.iconAlign;
            } else {
                btnIconCls  = me.baseCls + &#39;-&#39; + me.ui + &#39;-icon&#39;;
            }
        }
        else if (me.text) {
            me.addCls(me.baseCls + &#39;-&#39; + me.ui + &#39;-noicon&#39;);
        }

        Ext.applyIf(me.renderData, me.getTemplateArgs());

        // Extract the button and the button wrapping element
        Ext.applyIf(me.renderSelectors, {
            btnEl: &#39;button&#39;,
            btnWrap: &#39;em&#39;
        });

        // Render internal structure
        me.callParent(arguments);

        if (me.split &amp;&amp; me.arrowTooltip) {
            me.arrowEl.dom[me.tooltipType] = me.arrowTooltip;
        }
        me.mon(me.btnEl, {
            scope: me,
            focus: me.onFocus,
            blur : me.onBlur
        });

        btn = me.el;

        me.addCls(btnIconCls);

        if (me.icon) {
            me.setIcon(me.icon);
        }

        if (me.iconCls) {
            me.setIconClass(me.iconCls);
        }

        if (me.tooltip) {
            me.setTooltip(me.tooltip, true);
        }

        if (me.handleMouseEvents) {
            me.mon(btn, {
                scope: me,
                mouseover: me.onMouseOver,
                mouseout: me.onMouseOut,
                mousedown: me.onMouseDown
            });
        }

        if (me.menu) {
            me.mon(me.menu, {
                scope: me,
                show: me.onMenuShow,
                hide: me.onMenuHide
            });
        }

        if (me.repeat) {
            repeater = new Ext.util.ClickRepeater(btn, Ext.isObject(me.repeat) ? me.repeat: {});
            me.mon(repeater, &#39;click&#39;, me.onRepeatClick, me);
        } else {
            me.mon(btn, me.clickEvent, me.onClick, me);
        }
        Ext.ButtonToggleMgr.register(me);
    },

    /**
     * &lt;p&gt;This method returns an object which provides substitution parameters for the {@link #renderTpl XTemplate} used
     * to create this Button&#39;s DOM structure.&lt;/p&gt;
     * &lt;p&gt;Instances or subclasses which use a different Template to create a different DOM structure may need to provide their
     * own implementation of this method.&lt;/p&gt;
     * &lt;p&gt;The default implementation which provides data for the default {@link #template} returns an Object containing the
     * following properties:&lt;/p&gt;&lt;div class=&quot;mdetail-params&quot;&gt;&lt;ul&gt;
     * &lt;li&gt;&lt;code&gt;type&lt;/code&gt; : The &amp;lt;button&amp;gt;&#39;s {@link #type}&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;splitCls&lt;/code&gt; : A CSS class to determine the presence and position of an arrow icon. (&lt;code&gt;&#39;x-btn-arrow&#39;&lt;/code&gt; or &lt;code&gt;&#39;x-btn-arrow-bottom&#39;&lt;/code&gt; or &lt;code&gt;&#39;&#39;&lt;/code&gt;)&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;cls&lt;/code&gt; : A CSS class name applied to the Button&#39;s main &amp;lt;tbody&amp;gt; element which determines the button&#39;s scale and icon alignment.&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;text&lt;/code&gt; : The {@link #text} to display ion the Button.&lt;/li&gt;
     * &lt;li&gt;&lt;code&gt;tabIndex&lt;/code&gt; : The tab index within the input flow.&lt;/li&gt;
     * &lt;/ul&gt;&lt;/div&gt;
     * @return {Array} Substitution data for a Template.
    */
    getTemplateArgs: function() {
        var me = this;
        return {
            type     : me.type,
            splitCls : me.getSplitCls(),
            cls      : me.cls,
            text     : me.text || &#39;&amp;#160;&#39;,
            tabIndex : me.tabIndex
        };
    },

    getSplitCls: function() {
        return this.split ? (this.baseCls + &#39;-&#39; + this.arrowCls) + &#39; &#39; + (this.baseCls + &#39;-&#39; + this.arrowCls + &#39;-&#39; + this.arrowAlign) : &#39;&#39;;
    },

    // private
    afterRender: function() {
        var me = this;
        me.useSetClass = true;
        me.setButtonCls();
        me.doc = Ext.getDoc();
        this.callParent(arguments);
    },
    
    /**
     * Sets the CSS class that provides a background image to use as the button&#39;s icon.  This method also changes
     * the value of the {@link iconCls} config internally.
     * @param {String} cls The CSS class providing the icon image
     * @return {Ext.button.Button} this
     */
    setIconClass: function(cls) {
        var me = this;
        if (me.el) {
            // Remove the previous iconCls from the button
            me.btnEl.removeCls(me.iconCls);

            me.btnEl.addCls([me.baseCls + &#39;-text&#39;, cls || &#39;&#39;]);
            me.setButtonCls();
        }
        me.iconCls = cls;
        return me;
    },

    /**
     * Sets the tooltip for this Button.
     * @param {String/Object} tooltip. This may be:&lt;div class=&quot;mdesc-details&quot;&gt;&lt;ul&gt;
     * &lt;li&gt;&lt;b&gt;String&lt;/b&gt; : A string to be used as innerHTML (html tags are accepted) to show in a tooltip&lt;/li&gt;
     * &lt;li&gt;&lt;b&gt;Object&lt;/b&gt; : A configuration object for {@link Ext.tip.QuickTips#register}.&lt;/li&gt;
     * &lt;/ul&gt;&lt;/div&gt;
     * @return {Ext.button.Button} this
     */
    setTooltip: function(tooltip, initial) {
        var me = this;

        if (me.rendered) {
            if (!initial) {
                me.clearTip();
            }
            if (Ext.isObject(tooltip)) {
                Ext.tip.QuickTips.register(Ext.apply({
                    target: me.btnEl.id
                },
                tooltip));
                me.tooltip = tooltip;
            } else {
                me.btnEl.dom[me.tooltipType] = tooltip;
            }
        } else {
            me.tooltip = tooltip;
        }
        return me;
    },

    // private
    getRefItems: function(deep){
        var menu = this.menu,
            items;
        
        if (menu) {
            items = menu.getRefItems(deep);
            items.unshift(menu);
        }   
        return items || [];
    },

    // private
    clearTip: function() {
        if (Ext.isObject(this.tooltip)) {
            Ext.tip.QuickTips.unregister(this.btnEl);
        }
    },

    // private
    beforeDestroy: function() {
        var me = this;
        if (me.rendered) {
            me.clearTip();
        }
        if (me.menu &amp;&amp; me.destroyMenu !== false) {
            Ext.destroy(me.btnEl, me.menu);
        }
        Ext.destroy(me.repeater);
    },

    // private
    onDestroy: function() {
        var me = this;
        if (me.rendered) {
            me.doc.un(&#39;mouseover&#39;, me.monitorMouseOver, me);
            me.doc.un(&#39;mouseup&#39;, me.onMouseUp, me);
            delete me.doc;
            delete me.btnEl;
            Ext.ButtonToggleMgr.unregister(me);
        }
        me.callParent();
    },

    /**
     * Assigns this Button&#39;s click handler
     * @param {Function} handler The function to call when the button is clicked
     * @param {Object} scope (optional) The scope (&lt;code&gt;this&lt;/code&gt; reference) in which the handler function is executed.
     * Defaults to this Button.
     * @return {Ext.button.Button} this
     */
    setHandler: function(handler, scope) {
        this.handler = handler;
        this.scope = scope;
        return this;
    },

    /**
     * Sets this Button&#39;s text
     * @param {String} text The button text
     * @return {Ext.button.Button} this
     */
    setText: function(text) {
        var me = this;
        me.text = text;
        if (me.el) {
            me.btnEl.update(text || &#39;&amp;#160;&#39;);
            me.setButtonCls();
        }
        me.doComponentLayout();
        return me;
    },

    /**
     * Sets the background image (inline style) of the button.  This method also changes
     * the value of the {@link icon} config internally.
     * @param {String} icon The path to an image to display in the button
     * @return {Ext.button.Button} this
     */
    setIcon: function(icon) {
        var me = this;
        me.icon = icon;
        if (me.el) {
            me.btnEl.setStyle(&#39;background-image&#39;, icon ? &#39;url(&#39; + icon + &#39;)&#39;: &#39;&#39;);
            me.setButtonCls();
        }
        return me;
    },

    /**
     * Gets the text for this Button
     * @return {String} The button text
     */
    getText: function() {
        return this.text;
    },

    /**
     * If a state it passed, it becomes the pressed state otherwise the current state is toggled.
     * @param {Boolean} state (optional) Force a particular state
     * @param {Boolean} supressEvent (optional) True to stop events being fired when calling this method.
     * @return {Ext.button.Button} this
     */
    toggle: function(state, suppressEvent) {
        var me = this;
        state = state === undefined ? !me.pressed: !!state;
        if (state !== me.pressed) {
            if (me.rendered) {
                me.el[state ? &#39;addCls&#39;: &#39;removeCls&#39;]([me.baseCls + &#39;-pressed&#39;, me.pressedCls]);
            }
            me.btnEl.dom.setAttribute(&#39;aria-pressed&#39;, state);
            me.pressed = state;
            if (!suppressEvent) {
                me.fireEvent(&#39;toggle&#39;, me, state);
                Ext.callback(me.toggleHandler, me.scope || me, [me, state]);
            }
        }
        return me;
    },

    /**
     * Show this button&#39;s menu (if it has one)
     */
    showMenu: function() {
        var me = this;
        if (me.rendered &amp;&amp; me.menu) {
            if (me.tooltip) {
                Ext.tip.QuickTips.getQuickTip().cancelShow(me.btnEl);
            }
            if (me.menu.isVisible()) {
                me.menu.hide();
            }

            // Allow the menu to find a z-index parent on render by examining its ownerCt chain
            if (!me.menu.ownerCt) {
                me.menu.ownerCt = me.ownerCt;
            }

            me.menu.showBy(me.el, me.menuAlign);
        }
        return me;
    },

    /**
     * Hide this button&#39;s menu (if it has one)
     */
    hideMenu: function() {
        if (this.hasVisibleMenu()) {
            this.menu.hide();
        }
        return this;
    },

    /**
     * Returns true if the button has a menu and it is visible
     * @return {Boolean}
     */
    hasVisibleMenu: function() {
        var menu = this.menu;
        return menu &amp;&amp; menu.rendered &amp;&amp; menu.isVisible();
    },

    // private
    onRepeatClick: function(repeat, e) {
        this.onClick(e);
    },

    // private
    onClick: function(e) {
        var me = this;
        if (e) {
            e.preventDefault();
        }
        if (e.button !== 0) {
            return;
        }
        if (!me.disabled) {
            if (me.enableToggle &amp;&amp; (me.allowDepress !== false || !me.pressed)) {
                me.toggle();
            }
            if (me.menu &amp;&amp; !me.hasVisibleMenu() &amp;&amp; !me.ignoreNextClick) {
                me.showMenu();
            }
            me.fireEvent(&#39;click&#39;, me, e);
            if (me.handler) {
                me.handler.call(me.scope || me, me, e);
            }
        }
    },

    /**
     * @private mouseover handler called when a mouseover event occurs anywhere within the encapsulating element.
     * The targets are interrogated to see what is being entered from where.
     * @param e
     */
    onMouseOver: function(e) {
        var me = this,
            to = e.getTarget(),
            from = e.getRelatedTarget();

        if (to === this.el.dom) {
            if (from !== this.btnEl.dom || from !== this.btnWrap.dom) {
                this.onMouseEnter(e);
            }
        }
        else if (to === this.btnWrap.dom) {
            this.onMenuTriggerOver(e);
        }
    },

    /**
     * @private mouseout handler called when a mouseout event occurs anywhere within the encapsulating element -
     * or the mouse leaves the encapsulating element.
     * The targets are interrogated to see what is being exited to where.
     * @param e
     */
    onMouseOut: function(e) {
        var me = this,
            from = e.getTarget(),
            to = e.getRelatedTarget();

        if (from === this.el.dom) {
            if (to !== this.btnEl.dom &amp;&amp; to !== this.btnWrap.dom) {
                this.onMouseLeave(e);
            }
        }
        else if (from === me.btnWrap.dom) {
            me.onMenuTriggerOut(e);
        }
    },

    /**
     * @private virtual mouseenter handler called when it is detected that the mouseout event
     * signified the mouse entering the encapsulating element.
     * @param e
     */
    onMouseEnter: function(e) {
        var me = this;
        me.el.addCls([me.baseCls + &#39;-over&#39;, me.overCls]);
        me.fireEvent(&#39;mouseover&#39;, me, e);
    },

    /**
     * @private virtual mouseleave handler called when it is detected that the mouseover event
     * signified the mouse entering the encapsulating element.
     * @param e
     */
    onMouseLeave: function(e) {
        var me = this;
        me.el.removeCls([me.baseCls + &#39;-over&#39;, me.overCls]);
        me.fireEvent(&#39;mouseout&#39;, me, e);
    },

    /**
     * @private virtual mouseenter handler called when it is detected that the mouseover event
     * signified the mouse entering the arrow area of the button - the &lt;em&gt;.
     * @param e
     */
    onMenuTriggerOver: function(e) {
        var me = this,
            from = e.getRelatedTarget();

        me.overMenuTrigger = true;
        if (from !== me.el.dom &amp;&amp; from !== me.btnEl.dom) {
            me.onMouseEnter(e);
        }
        me.fireEvent(&#39;menutriggerover&#39;, me, me.menu, e);
    },

    /**
     * @private virtual mouseleave handler called when it is detected that the mouseout event
     * signified the mouse leaving the arrow area of the button - the &lt;em&gt;.
     * @param e
     */
    onMenuTriggerOut: function(e) {
        var me = this,
            to = e.getRelatedTarget();

        delete me.overMenuTrigger;
        me.fireEvent(&#39;menutriggerout&#39;, me, me.menu, e);
        if (to !== me.el.dom &amp;&amp; to !== me.btnEl.dom) {
            me.onMouseLeave(e);
        }
    },

    focus: function() {
        this.btnEl.focus();
    },

    blur: function() {
        this.btnEl.blur();
    },

    // private
    onFocus: function(e) {
        var me = this;
        if (!me.disabled) {
            me.el.addCls([me.baseCls + &#39;-focus&#39;, me.focusCls]);
        }
    },
    // private
    onBlur: function(e) {
        var me = this;
        me.el.removeCls([me.baseCls + &#39;-focus&#39;, me.focusCls]);
    },

    // private
    onMouseDown: function(e) {
        var me = this;
        if (!me.disabled &amp;&amp; e.button === 0) {
            me.el.addCls([me.baseCls + &#39;-pressed&#39;, me.pressedCls]);
            me.doc.on(&#39;mouseup&#39;, me.onMouseUp, me);
        }
    },
    // private
    onMouseUp: function(e) {
        var me = this;
        if (e.button === 0) {
            me.el.removeCls([me.baseCls + &#39;-pressed&#39;, me.pressedCls]);
            me.doc.un(&#39;mouseup&#39;, me.onMouseUp, me);
        }
    },
    // private
    onMenuShow: function(e) {
        var me = this;
        me.ignoreNextClick = 0;
        me.el.addCls(me.baseCls + &#39;-menu-active&#39;);
        me.fireEvent(&#39;menushow&#39;, me, me.menu);
    },

    // private
    onMenuHide: function(e) {
        var me = this;
        me.el.removeCls(me.baseCls + &#39;-menu-active&#39;);
        me.ignoreNextClick = Ext.defer(me.restoreClick, 250, me);
        me.fireEvent(&#39;menuhide&#39;, me, me.menu);
    },

    // private
    restoreClick: function() {
        this.ignoreNextClick = 0;
    }
}, function() {
    var groups = {},
        g, i, l;

    function toggleGroup(btn, state) {
        if (state) {
            g = groups[btn.toggleGroup];
            for (i = 0, l = g.length; i &lt; l; i++) {
                if (g[i] !== btn) {
                    g[i].toggle(false);
                }
            }
        }
    }
    // Private utility class used by Button
    Ext.ButtonToggleMgr = {
        register: function(btn) {
            if (!btn.toggleGroup) {
                return;
            }
            var g = groups[btn.toggleGroup];
            if (!g) {
                g = groups[btn.toggleGroup] = [];
            }
            g.push(btn);
            btn.on(&#39;toggle&#39;, toggleGroup);
        },

        unregister: function(btn) {
            if (!btn.toggleGroup) {
                return;
            }
            var g = groups[btn.toggleGroup];
            if (g) {
                g.remove(btn);
                btn.un(&#39;toggle&#39;, toggleGroup);
            }
        },

        /**
        * Gets the pressed button in the passed group or null
        * @param {String} group
        * @return Button
        */
        getPressed: function(group) {
            var g = groups[group],
                i = 0,
                len;
            if (g) {
                for (len = g.length; i &lt; len; i++) {
                    if (g[i].pressed === true) {
                        return g[i];
                    }
                }
            }
            return null;
        }
    };
});ï¿¿</pre></pre></body></html>