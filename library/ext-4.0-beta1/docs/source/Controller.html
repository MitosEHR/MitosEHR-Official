<!DOCTYPE html><html><head><title>Sencha Documentation Project</title><link rel="stylesheet" href="../reset.css" type="text/css"><link rel="stylesheet" href="../prettify.css" type="text/css"><link rel="stylesheet" href="../prettify_sa.css" type="text/css"><script type="text/javascript" src="../prettify.js"></script></head><body onload="prettyPrint()"><pre class="prettyprint"><pre><a name="cls-Ext.Controller"></a>/**
 * @class Ext.Controller
 * @author Ed Spencer
 *
 * &lt;p&gt;Controllers are the glue that binds applications together. In the MVC paradigm we have three main elements -
 * Models, Views and Controllers. Sencha frameworks have a strong {@link Ext.data.Model Model} layer which makes it
 * easy to manage all of the application&#39;s data. Views are simply the Components that create the UI of your
 * application. Controllers are what stitch the M and the V together - they&#39;re the place to put any logic that defines
 * the flow of the application, and typically transmit the user&#39;s interactions from the View to the Model.&lt;/p&gt;
 *
 * &lt;p&gt;&lt;u&gt;Rendering&lt;/u&gt;&lt;/p&gt;
 *
 * &lt;p&gt;Controllers can be used to render components onto the screen. Although components can be created and rendered in
 * other ways, creating them via a controller gives us a central place to put code that responds to interactions with
 * the view. For example, if we render a button component, we want to perform some action when it is clicked. We can
 * place the logic for that action in a controller:&lt;/p&gt;
 *
<br><span style="display: none">**/</span>Ext.regController(&#39;contacts&#39;, {
    list: function() {
        this.render({
            xtype: &#39;button&#39;,
            text : &#39;Login&#39;,
            scope: this,
            handler: this.onLoginClick
        });
    },

    //this is called when the button is clicked
    onLoginClick: function() {
        alert(&#39;Logged in!&#39;);
    }
});
<br><span style="display: none">/**</span> *
 * @constructor
 */
Ext.define(&#39;Ext.Controller&#39;, {
    requires: [&#39;Ext.ControllerManager&#39;],

    mixins: {
        observable: &#39;Ext.util.Observable&#39;
    },

    constructor: function(config) {
        this.addEvents(
            <a name="event-Ext.Controller-instance-created"></a>/**
             * @event instance-created
             * Fired when a new model instance has been successfully created by this controller
             * @param {Ext.data.Model} instance The newly-created model instance
             */
            &#39;instance-created&#39;,

            <a name="event-Ext.Controller-instance-creation-failed"></a>/**
             * @event instance-creation-failed
             * Fired when an attempt at saving a new instance failed
             * @param {Ext.data.Model} instance The instance that could not be saved
             * @param {Object} errors The set of errors (if any) that caused the failure
             */
            &#39;instance-creation-failed&#39;,

            <a name="event-Ext.Controller-instance-updated"></a>/**
             * @event instance-updated
             * Fired when an existing model instance has been successfully updated by this controller
             * @param {Ext.data.Model} instance The instance that was updated
             */
            &#39;instance-updated&#39;,

            <a name="event-Ext.Controller-instance-update-failed"></a>/**
             * @event instance-update-failed
             * Fired when an update to existing model instance could not be successfully completed
             * @param {Ext.data.Model} instance The instance that could not be updated
             * @param {Object} errors The set of errors (if any) that caused the failure
             */
            &#39;instance-update-failed&#39;,

            <a name="event-Ext.Controller-instance-destroyed"></a>/**
             * @event instance-destroyed
             * Fired when an existing instance has been successfully destroyed by this controller
             * @param {Ext.data.Model} instance The instance that was destroyed
             */
            &#39;instance-destroyed&#39;,

            <a name="event-Ext.Controller-instance-destruction-failed"></a>/**
             * @event instance-destruction-failed
             * Fired when an existing instance could not be destroyed
             * @param {Ext.data.Model} instance The instance that could not be destroyed
             * @param {Object} errors The set of errors (if any) that caused the failure
             */
            &#39;instance-destruction-failed&#39;
        );

        this.mixins.observable.constructor.call(this, config);

        Ext.apply(this, config || {});

        if (typeof this.model == &#39;string&#39;) {
            this.model = Ext.ModelMgr.getModel(this.model);
        }
    },

    index: function() {
        this.render(&#39;index&#39;, {
            listeners: {
                scope  : this,
                edit   : this.edit,
                build  : this.build,
                create : this.onCreateInstance,
                destroy: this.onDestroyInstance
            }
        });
    },

    <a name="method-Ext.Controller-edit"></a>/**
     * Renders the edit form for a given model instance
     * @param {Ext.data.Model} instance The instance to edit
     */
    edit: function(instance) {
        var view = this.render(&#39;edit&#39;, {
            listeners: this.getEditListeners()
        });

        view.loadModel(instance);
    },

    <a name="method-Ext.Controller-build"></a>/**
     * Callback automatically tied to the index view&#39;s &#39;build&#39; event. By default this just renders the registered
     * &#39;build&#39; view
     */
    build: function() {
        this.render(&#39;build&#39;, {
            listeners: this.getBuildListeners()
        });
    },

    <a name="method-Ext.Controller-create"></a>/**
     * Saves a phantom Model instance via its configured Proxy. Fires the &#39;instance-created&#39; event if successful,
     * the &#39;instance-creation-failed&#39; event if not.
     * @param {Object} data The data to create the instance from
     * @param {Object} options Optional options object containing callbacks for success and failure plus optional scope
     */
    create: function(data, options) {
        options = options || {};

        var model     = this.getModel(),
            instance  = new model(data),
            successCb = options.success,
            failureCb = options.failure,
            scope     = options.scope || this;

        instance.save({
            scope  : this,
            success: function(instance) {
                if (typeof successCb == &#39;function&#39;) {
                    successCb.call(scope, instance);
                }

                this.fireEvent(&#39;instance-created&#39;, instance);
            },
            failure: function(instance, errors) {
                if (typeof failureCb == &#39;function&#39;) {
                    failureCb.call(scope, instance, errors);
                }

                this.fireEvent(&#39;instance-creation-failed&#39;, instance, errors);
            }
        });
    },

    <a name="method-Ext.Controller-update"></a>/**
     * Updates an existing model instance by applying optional updates to it and attempting to save
     * @param {Ext.data.Model} instance The existing instance
     * @param {Object} updates Optional additional updates to apply to the instance before saving
     * @param {Object} options success and failure callback functions
     */
    update: function(instance, updates, options) {
        options = options || {};

        var successCb = options.success,
            failureCb = options.failure,
            scope     = options.scope || this;

        if (Ext.isObject(updates)) {
            instance.set(updates);
        }

        instance.save({
            scope  : this,
            success: function(instance) {
                if (typeof successCb == &#39;function&#39;) {
                    successCb.call(scope, instance);
                }

                this.fireEvent(&#39;instance-updated&#39;, instance);
            },
            failure: function(instance, errors) {
                if (typeof failureCb == &#39;function&#39;) {
                    failureCb.call(scope, instance, errors);
                }

                this.fireEvent(&#39;instance-update-failed&#39;, instance, errors);
            }
        });
    },

    <a name="method-Ext.Controller-destroy"></a>/**
     * Destroys one or more existing, previously saved model instances
     * @param {Ext.data.Model} instance The model instance to destroy
     * @param {Object} options success and failure callbacks
     */
    destroy: function(instance, options) {
        options = options || {};

        var successCb = options.success,
            failureCb = options.failure,
            scope     = options.scope || this;

        instance.destroy({
            scope  : this,
            success: function(instance) {
                if (typeof successCb == &#39;function&#39;) {
                    successCb.call(scope, instance);
                }

                this.fireEvent(&#39;instance-destroyed&#39;, instance);
            },
            failure: function(instance, errors) {
                if (typeof failureCb == &#39;function&#39;) {
                    failureCb.call(scope, instance, errors);
                }

                this.fireEvent(&#39;instance-destruction-failed&#39;, instance, errors);
            }
        });
    },

    <a name="method-Ext.Controller-getBuildListeners"></a>/**
     * Returns the listeners to attach to the view rendered by the {@link #build} action. By default this returns listeners
     * for save and cancel, but this can be overridden
     * @return {Object} listeners
     */
    getBuildListeners: function() {
        return {
            scope : this,
            save  : this.onCreateInstance,
            cancel: this.onCancelBuild
        };
    },

    <a name="method-Ext.Controller-getEditListeners"></a>/**
     * Returns the listeners to attach to the view rendered by the {@link #edit} action. By default this returns listeners
     * for save and cancel, but this can be overridden
     * @return {Object} listeners
     */
    getEditListeners: function() {
        return {
            scope : this,
            save  : this.onUpdateInstance,
            cancel: this.onCancelEdit
        };
    },

    <a name="method-Ext.Controller-onCancelEdit"></a>/**
     * Handler for the &#39;cancel&#39; event fired by an {@link #edit} view. By default this just closes the view
     * @param {Ext.Component} view The edit form
     */
    onCancelEdit: function(view) {
        return this.closeView(view);
    },

    <a name="method-Ext.Controller-onCancelBuild"></a>/**
     * Handler for the &#39;cancel&#39; event fired by an {@link #build} view. By default this just closes the view
     * @param {Ext.Component} view The build form
     */
    onCancelBuild: function(view) {
        return this.closeView(view);
    },

    <a name="method-Ext.Controller-onCreateInstance"></a>/**
     * Callback automatically tied to the index view&#39;s &#39;create&#39; event. By default this just calls the controller&#39;s
     * create function with the data and some basic callbacks to handle errors or show success. Can be overridden
     * to provide custom behavior
     * @param {Ext.View} view The view instance that fired the event
     */
    onCreateInstance: function(view) {
        this.create(view.getValues(), {
            scope  : this,
            success: function(instance) {
                this.closeView(view);
            },
            failure: function(instance, errors) {

            }
        });
    },

    <a name="method-Ext.Controller-onUpdateInstance"></a>/**
     * Callback automatically tied to the index view&#39;s &#39;update&#39; event. By default this just calls the controller&#39;s
     * update function with the data and some basic callbacks to handle errors or show success. Can be overridden
     * to provide custom behavior
     * @param {Ext.Component} view The view instance that fired the event
     */
    onUpdateInstance: function(view) {
        this.update(view.getRecord(), view.getValues(), {
            scope  : this,
            success: function(instance) {
                this.closeView(view);
            },
            failure: function(instance, errors) {

            }
        });
    },

    <a name="method-Ext.Controller-onDestroyInstance"></a>/**
     * Callback automatically tied to the index view&#39;s &#39;destroy&#39; event. By default that just calls the controller&#39;s
     * destroy function with the model instance and some basic callbacks to handle errors or show success. Can be
     * overridden to provide custom behavior.
     * @param {Ext.data.Model} instance The instance to destroy
     * @param {Ext.View} view The view instance that fired the event
     */
    onDestroyInstance: function(instance, view) {
        this.destroy(instance, {
            scope  : this,
            success: function(instance) {

            },
            failure: function(instance, errors) {

            }
        });
    },

    <a name="method-Ext.Controller-setRenderTarget"></a>/**
     * Sets the default container that components rendered using {@link #render} will be added to.
     * In many applications there is a fixed navigation panel and a content panel - the content
     * panel would usually form the render target in this type of setup.
     * @param {Ext.container.Container} target The container to add rendered components to
     */
    setRenderTarget: function(target) {
        <a name="prop-Ext.Controller-renderTarget"></a>/**
         * @property renderTarget
         * @type Ext.container.Container
         * The current {@link #setRenderTarget render target}. Read only
         */
        Ext.Controller.renderTarget = target;
    },

    <a name="method-Ext.Controller-render"></a>/**
     * Renders a given view based on a registered name
     * @param {String} viewName The name of the view to render
     * @param {Object} config Optional config object
     * @return {Ext.View} The view instance
     */
    render: function(config, target) {
        var Controller  = Ext.Controller,
            application = this.application,
            profile     = application ? application.currentProfile : undefined,
            profileTarget, view;

        Ext.applyIf(config, {
            profile: profile
        });

        view = Ext.createByAlias(config.xtype, config);

        if (target !== false) {
            //give the current Ext.Profile a chance to set the target
            profileTarget = profile ? profile.getRenderTarget(config, application) : target;

            if (target == undefined) {
                target = profileTarget || (application ? application.defaultTarget : undefined);
            }

            if (typeof target == &#39;string&#39;) {
                target = Ext.getCmp(target);
            }

            if (target != undefined &amp;&amp; target.add) {
                if (profile) {
                    profile.beforeLayout(view, target, application);
                }

                target.add(view);

                if (target.layout &amp;&amp; target.layout.setActiveItem) {
                    target.layout.setActiveItem(view);
                }

                target.doComponentLayout();

                if (profile) {
                    profile.afterLayout(view, target, application);
                }
            }
        }

        return view;
    },

    <a name="method-Ext.Controller-control"></a>/**
     * This function allows you to add listeners to a view
     * in a convenient way
     */
    control : function(view, actions, itemName) {
        if (!view || !view.isView) {
            throw &#39;Trying to control a view that doesnt exist&#39;;
        }

        var item = itemName ? view.refs[itemName] : view,
            key, value, name, child, listener;

        if (!item) {
            throw &quot;No item called &quot; + itemName + &quot; found inside the &quot; + view.name + &quot; view.&quot;;
        }

        for (key in actions) {
            value = actions[key];

            // If it is an object, it can either be a listener with a handler defined
            // in which case the key is the event name, or it can be an object containing
            // listener(s), in which case key will be the items name
            if (Ext.isObject(value) &amp;&amp; !value.fn) {
                this.control(view, value, key);
            }
            else {
                // Now hopefully we can be sure that key is an event name. We will loop over all
                // child items and enable bubbling for this event
                if (item.refs) {
                    for (name in item.refs) {
                        child = item.refs[name];
                        if (child.isObservable &amp;&amp; child.events[key]) {
                            child.enableBubble(key);
                        }
                    }
                }

                if (!value.fn) {
                    listener = {};
                    listener[key] = value;
                    listener.scope = this;
                }
                else {
                    listener = value;
                    if (listener.scope === undefined) {
                        listener.scope = this;
                    }
                }

                // Finally we bind the listener on this item
                item.addListener(listener);
            }
        }

        return view;
    },

    <a name="method-Ext.Controller-getModel"></a>/**
     * Returns the constructor for the model type linked to this controller
     * @return {Ext.data.Model} The model constructor
     */
    getModel: function() {
        return Ext.ModelMgr.getModel(this.model);
    },

    /**
     * @private
     * Used internally whenever we want to remove a component from its parent container. See onCancelEdit and onCancelBuild
     * @param {Ext.Component} view The component to close
     */
    closeView: function(view) {
        var ownerCt = view.ownerCt;

        if (ownerCt) {
            ownerCt.remove(view);
            ownerCt.setActiveItem(ownerCt.items.last());
        }
    }
});
ï¿¿</pre></pre></body></html>