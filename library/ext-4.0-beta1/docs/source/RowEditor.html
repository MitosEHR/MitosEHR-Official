<!DOCTYPE html><html><head><title>Sencha Documentation Project</title><link rel="stylesheet" href="../reset.css" type="text/css"><link rel="stylesheet" href="../prettify.css" type="text/css"><link rel="stylesheet" href="../prettify_sa.css" type="text/css"><script type="text/javascript" src="../prettify.js"></script></head><body onload="prettyPrint()"><pre class="prettyprint"><pre>// Currently has the following issues:
// - Does not handle postEditValue
// - Fields without editors need to sync with their values in Store
// - starting to edit another record while already editing and dirty should probably prevent it
// - aggregating validation messages
// - tabIndex is not managed bc we leave elements in dom, and simply move via positioning
// - layout issues when changing sizes/width while hidden (layout bug)

<a name="cls-Ext.grid.RowEditor"></a>/**
 * @class Ext.grid.RowEditor
 * @extends Ext.form.FormPanel
 */
Ext.define(&#39;Ext.grid.RowEditor&#39;, {
    extend: &#39;Ext.form.FormPanel&#39;,
    requires: [
        &#39;Ext.tip.ToolTip&#39;,
        &#39;Ext.util.HashMap&#39;,
        &#39;Ext.util.KeyNav&#39;
    ],

    saveBtnText  : &#39;Update&#39;,
    cancelBtnText: &#39;Cancel&#39;,
    errorsText: &#39;Errors&#39;,
    
    lastScrollLeft: 0,
    lastScrollTop: 0,
    
    border: false,

    initComponent: function() {
        var me = this,
            form;
        
        me.cls = Ext.baseCSSPrefix + &#39;grid-row-editor&#39;;
        
        me.layout = {
            type: &#39;hbox&#39;
        };
        
        // Maintain field-to-column mapping
        // It&#39;s easy to get a field from a column, but not vice versa
        me.columns = Ext.create(&#39;Ext.util.HashMap&#39;);
        me.columns.getKey = function(o) {
            var f;
            if (o.getField &amp;&amp; (f = o.getField())) {
                return f.id;
            }
            return o.id;
        };
        me.mon(me.columns, {
            add: me.onFieldAdd,
            remove: me.onFieldRemove,
            replace: me.onFieldReplace,
            scope: me
        });
        
        me.callParent(arguments);
        
        if (me.fields) {
            me.setField(me.fields);
            delete me.fields;
        }
        
        form = me.getForm();
        form.trackResetOnLoad = true;
        if (me.errorSummary) {
            me.mon(form, &#39;validitychange&#39;, me.onValidityChange, me);
        }
    },
    
    onValidityChange: function(form, valid) {
        var me = this;
        if (me.isVisible()) {
            me[valid ? &#39;hideToolTip&#39; : &#39;showToolTip&#39;]();
        }
    },

    afterRender: function() {
        var me = this,
            plugin = me.editingPlugin;
        me.callParent(arguments);
        me.renderTo.on(&#39;scroll&#39;, me.onCtScroll, me, { buffer: 100 });
        
        // Prevent from bubbling click events to the grid view
        me.mon(me.el, {
            click: Ext.emptyFn,
            stopPropagation: true
        });
        
        me.keyNav = Ext.create(&#39;Ext.util.KeyNav&#39;, me.el, {
            enter: plugin.completeEdit,
            scope: plugin
        });
        
        me.mon(plugin.view, {
            beforerefresh: me.onBeforeViewRefresh,
            refresh: me.onViewRefresh,
            scope: me
        });
    },
    
    onBeforeViewRefresh: function(view) {
        var me = this,
            viewDom = view.el.dom;
        
        if (me.el.dom.parentNode === viewDom) {
            viewDom.removeChild(me.el.dom);
        }
    },
    
    onViewRefresh: function(view) {
        var me = this,
            viewDom = view.el.dom,
            params = me.params,
            idx;
            
        viewDom.appendChild(me.el.dom);
        
        // Recover our row node after a view refresh
        if (params &amp;&amp; (idx = params.store.indexOf(params.record)) &gt;= 0) {
            params.row = view.getNode(idx);
            me.reposition();
            if (me.tooltip &amp;&amp; me.tooltip.isVisible()) {
                me.tooltip.initTarget(params.row);
            }
        } else {
            me.editingPlugin.cancelEdit();
        }
    },
    
    onCtScroll: function(e, target) {
        var me = this,
            scrollTop  = target.scrollTop,
            scrollLeft = target.scrollLeft;
        
        if (scrollTop !== me.lastScrollTop) {
            me.lastScrollTop = scrollTop;
            if (me.tooltip.isVisible() || me.hiddenTip) {
                me.repositionTip();
            }
        }
        if (scrollLeft !== me.lastScrollLeft) {
            me.lastScrollLeft = scrollLeft;
            me.reposition();
        }
    },
    
    onColumnAdd: function(column) {
        this.setField(column);
    },
    
    onColumnRemove: function(column) {
        this.columns.remove(column);
    },
    
    onColumnResize: function(column, width) {
        column.getField().setWidth(width - 5);
        this.reposition();
    },
    
    onColumnHide: function(column) {
        column.getField().hide();
        this.reposition();
    },
    
    onColumnShow: function(column) {
        column.getField().show();
        this.reposition();
    },
    
    onColumnMove: function(column, fromIdx, toIdx) {
        this.move(fromIdx, toIdx);
    },
    
    onFieldAdd: function(hm, fieldId, column) {
        var me = this,
            colIdx = me.editingPlugin.grid.headerCt.getIndexOfHeader(column),
            field = column.getField({ xtype: &#39;displayfield&#39; });
        
        me.insert(colIdx, field);
    },
    
    onFieldRemove: function(hm, fieldId, column) {
        var me = this,
            field = column.getField(),
            fieldDom = field.el.dom;
        me.remove(field, false);
        fieldDom.parentNode.removeChild(fieldDom);
    },
    
    onFieldReplace: function(hm, fieldId, column, oldColumn) {
        var me = this;
        me.onFieldRemove(hm, fieldId, oldColumn);
    },
    
    clearFields: function() {
        var me = this,
            hm = me.columns;
        hm.each(function(fieldId) {
            hm.removeByKey(fieldId);
        });
    },

    getFloatingButtons: function() {
        var me = this,
            cssPrefix = Ext.baseCSSPrefix,
            btnsCss = cssPrefix + &#39;grid-row-editor-buttons&#39;,
            plugin = me.editingPlugin,
            btns;
        
        if (!me.floatingButtons) {
            btns = me.floatingButtons = new Ext.Container({
                renderTpl: [
                    &#39;&lt;div class=&quot;{baseCls}-ml&quot;&gt;&lt;/div&gt;&#39;,
                    &#39;&lt;div class=&quot;{baseCls}-mr&quot;&gt;&lt;/div&gt;&#39;,
                    &#39;&lt;div class=&quot;{baseCls}-bl&quot;&gt;&lt;/div&gt;&#39;,
                    &#39;&lt;div class=&quot;{baseCls}-br&quot;&gt;&lt;/div&gt;&#39;,
                    &#39;&lt;div class=&quot;{baseCls}-bc&quot;&gt;&lt;/div&gt;&#39;
                ],
                
                renderTo: me.el,
                baseCls: btnsCss,
                layout: &#39;hbox&#39;,
                defaults: {
                    margins: &#39;0 1 1 1&#39;
                },
                items: [{
                    flex: 1,
                    xtype: &#39;button&#39;,
                    handler: plugin.completeEdit,
                    scope: plugin,
                    text: me.saveBtnText
                }, {
                    flex: 1,
                    xtype: &#39;button&#39;,
                    handler: plugin.cancelEdit,
                    scope: plugin,
                    text: me.cancelBtnText
                }]
            });
            
            // Prevent from bubbling click events to the grid view
            me.mon(btns.el, {
                click: Ext.emptyFn,
                stopEvent: true
            });
        }
        
        return me.floatingButtons;
    },

    // floating buttons are positioned independently of the roweditor itself
    // this method will reposition the buttons to be immediately below 
    reposition: function(animate) {
        var me = this,
            params = me.params,
            row = params &amp;&amp; Ext.get(params.row),
            btns = me.getFloatingButtons(),
            btnEl = btns.el,
            grid = me.editingPlugin.grid,
            scroller = grid.verticalScroller,
            
            // always get data from ColumnModel as its what drives
            // the GridView&#39;s sizing
            mainBodyWidth = grid.headerCt.getFullWidth(),
            scrollerWidth = grid.getWidth(),
            
            // use the minimum as the columns may not fill up the entire grid
            // width
            width = Math.min(mainBodyWidth, scrollerWidth),
            scrollLeft = grid.view.el.dom.scrollLeft,
            btnWidth = btns.getWidth(),
            left = (width - btnWidth) / 2 + scrollLeft,
            
            top, rowH, newHeight,
            
            invalidateScroller = function() {
                if (animate &amp;&amp; animate.callback) {
                    animate.callback();
                }
                if (scroller) {
                    scroller.invalidate();
                }
            };

        // need to set both top/left
        if (row &amp;&amp; Ext.isElement(row.dom)) {
            top = row.dom.offsetTop - 5;
            rowH = row.getHeight();
            newHeight = rowH + 10;
            
            // IE doesn&#39;t set the height quite right.
            // This isn&#39;t a border-box issue, it even happens
            // in IE8 and IE7 quirks.
            // TODO: Test in IE9!
            if (Ext.isIE) {
                newHeight += 2;
            }
            
            if (me.getHeight() != newHeight) {
                me.setHeight(newHeight);
                me.resizeFields(rowH);
                me.el.setLeft(0);
            }
            
            if (animate) {
                var animObj = {
                    to: {
                        top: top
                    },
                    listeners: {
                        afteranimate: invalidateScroller
                    }
                };
                me.animate(animObj);
            } else {
                me.el.setTop(top);
                invalidateScroller();
            }
        }
        if (me.getWidth() != mainBodyWidth) {
            me.setWidth(mainBodyWidth);
        }
        btnEl.setLeft(left);
    },
    
    resizeFields: function(height) {
        var me = this;
        
        Ext.Array.forEach(me.query(&#39;&gt;[isFormField]&#39;), function(field) {
            if (field.getHeight() != height) {
                field.setHeight(height);
            }
        }, me);
    },
    
    getField: function(fieldInfo) {
        var me = this;
        
        if (Ext.isNumber(fieldInfo)) {
            // Query only form fields. This just future-proofs us incase we add
            // other components to RowEditor later on.  Don&#39;t want to mess with
            // indicies.
            return me.query(&#39;&gt;[isFormField]&#39;)[fieldInfo];
        } else if (fieldInfo instanceof Ext.grid.Header) {
            return fieldInfo.getField();
        }
    },
    
    removeField: function(field) {
        var me = this;
        
        // Incase we pass a column instead, which is fine
        field = me.getField(field);
        
        // Remove field/column from our mapping, which will fire the event to
        // remove the field from our container
        me.columns.removeKey(field.id);
    },
    
    setField: function(column) {
        var me = this,
            field;
        
        if (Ext.isArray(column)) {
            Ext.Array.forEach(column, me.setField, me);
            return;
        }
        
        // Get a default display field if necessary
        field = column.getField({ xtype: &#39;displayfield&#39; });
        field.margins = &#39;5 0 5 2&#39;;
        field.setWidth(column.getWidth() - 2);
        
        // Maintain mapping of fields-to-columns
        // This will fire events that maintain our container items
        me.columns.add(field.id, column);
    },
    
    loadRecord: function(record) {
        var me = this;
        me.getForm().loadRecord(record);
        
        // render display fields so they honor the column renderer/template
        Ext.Array.forEach(me.query(&#39;&gt;displayfield&#39;), function(field) {
            me.renderColumnData(field, record);
        }, me);
    },
    
    renderColumnData: function(field, record) {
        var me = this,
            grid = me.editingPlugin.grid,
            headerCt = grid.headerCt,
            view = grid.view,
            store = view.store,
            column = me.columns.get(field.id),
            value = field.getRawValue();
        
        // honor our column&#39;s renderer (TemplateHeader sets renderer for us!)
        if (column.renderer) {
            var metaData = { tdCls: &#39;&#39;, style: &#39;&#39; },
                rowIdx = store.indexOf(record),
                colIdx = headerCt.getIndexOfHeader(column);
            
            value = column.renderer.call(
                column.scope || headerCt.ownerCt,
                value,
                metaData,
                record,
                rowIdx,
                colIdx,
                store,
                view
            );
        }
        
        field.setRawValue(value);
        field.resetOriginalValue();
    },

    startEdit: function(params) {
        var me = this,
            field,
            
            focusCell = function() {
                field = me.getField(params.colIdx);
                if (field &amp;&amp; field.focus) {
                    field.focus();
                }
            };
        
        // Store our params
        me.params = params;

        me.loadRecord(params.record);
        
        if (!me.isVisible()) {
            me.show();
            focusCell();
        } else {
            me.reposition({
                animate: true,
                callback: focusCell
            });
        }
    },

    cancelEdit: function() {
        var me = this,
            form = me.getForm();
        me.hide();
        form.clearInvalid();
        form.reset();
    },

    completeEdit: function() {
        var me = this,
            form = me.getForm();
            
        if (!form.isValid()) {
            return;
        }
        
        form.updateRecord(me.params.record);
        me.hide();
        return true;
    },

    // synchronize the floating buttons panel
    onShow: function() {
        var me = this;
        me.callParent(arguments);
        me.reposition();
        me.hideToolTip();
    },

    // synchronize the floating buttons panel
    onHide: function() {
        var me = this;
        me.callParent(arguments);
        me.hideToolTip();
        if (me.params) {
            me.params.view.focus();
        }
    },
    
    isDirty: function() {
        var me = this,
            form = me.getForm();
        return form.isDirty();
    },
    
    getToolTip: function() {
        var me = this,
            tip;
        
        if (!me.tooltip) {
            tip = me.tooltip = Ext.createWidget(&#39;tooltip&#39;, {
                cls: Ext.baseCSSPrefix + &#39;grid-row-editor-errors&#39;,
                title: me.errorsText,
                autoHide: false,
                closable: true,
                closeAction: &#39;disable&#39;,
                anchor: &#39;left&#39;
            });
        }
        
        return me.tooltip;
    },
    
    hideToolTip: function() {
        var me = this,
            tip = me.getToolTip();
        if (tip.rendered) {
            tip.disable();
        }
        me.hiddenTip = false;
    },
    
    showToolTip: function() {
        var me = this,
            tip = me.getToolTip(),
            params = me.params,
            row = Ext.get(params.row),
            viewEl = params.grid.view.el;
        
        tip.initTarget(row);
        tip.showAt(-10000, -10000);
        tip.body.update(me.getErrors());
        tip.mouseOffset = [viewEl.getWidth() - row.getWidth() + me.lastScrollLeft + 15, 0];
        me.repositionTip();
        tip.doLayout();
        tip.enable();
    },
    
    repositionTip: function() {
        var me = this,
            tip = me.getToolTip(),
            params = me.params,
            row = Ext.get(params.row),
            viewEl = params.grid.view.el,
            viewHeight = viewEl.getHeight(),
            viewTop = me.lastScrollTop,
            viewBottom = viewTop + viewHeight,
            rowHeight = row.getHeight(),
            rowTop = row.dom.offsetTop,
            rowBottom = rowTop + rowHeight;
        
        if (rowBottom &gt; viewTop &amp;&amp; rowTop &lt; viewBottom) {
            tip.show();
            me.hiddenTip = false;
        } else {
            tip.hide();
            me.hiddenTip = true;
        }
    },
    
    getErrors: function() {
        var me = this,
            errors = [];
        
        Ext.Array.forEach(me.query(&#39;&gt;[isFormField]&#39;), function(field) {
            errors = errors.concat(
                Ext.Array.map(field.getErrors(), function(e) {
                    return &#39;&lt;li&gt;&#39; + e + &#39;&lt;/li&gt;&#39;;
                })
            );
        }, me);
        
        return &#39;&lt;ul&gt;&#39; + errors.join(&#39;&#39;) + &#39;&lt;/ul&gt;&#39;;
    }
});ï¿¿</pre></pre></body></html>