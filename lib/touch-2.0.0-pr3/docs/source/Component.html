<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">(function(clsPrefix) {

<span id='Ext-Component'>/**
</span> * Most of the visual classes you interact with in Sencha Touch are Components. Every Component in Sencha Touch is a
 * subclass of Ext.Component, which means they can all:
 *
 * * Render themselves onto the page using a template
 * * Show and hide themselves at any time
 * * Center themselves on the screen
 * * Enable and disable themselves
 *
 * They can also do a few more advanced things:
 *
 * * Float above other components (windows, message boxes and overlays)
 * * Change size and position on the screen with animation
 * * Dock other Components inside itself (useful for toolbars)
 * * Align to other components, allow themselves to be dragged around, make their content scrollable &amp; more
 *
 * ## Available Components
 *
 * There are many components available in Sencha Touch, separated into 4 main groups:
 *
 * ### Navigation components
 * * {@link Ext.Toolbar}
 * * {@link Ext.Button}
 * * {@link Ext.TitleBar}
 * * {@link Ext.SegmentedButton}
 * * {@link Ext.Title}
 * * {@link Ext.Spacer}
 *
 * ### Store-bound components
 * * {@link Ext.dataview.DataView}
 * * {@link Ext.dataview.ComponentView}
 * * {@link Ext.Carousel}
 * * {@link Ext.List}
 * * {@link Ext.NestedList}
 *
 * ### Form components
 * * {@link Ext.form.Panel}
 * * {@link Ext.form.FieldSet}
 * * {@link Ext.field.Checkbox}
 * * {@link Ext.field.Hidden}
 * * {@link Ext.field.Slider}
 * * {@link Ext.field.Text}
 * * {@link Ext.picker.Picker}
 * * {@link Ext.picker.Date}
 *
 * ### General components
 * * {@link Ext.Panel}
 * * {@link Ext.tab.Panel}
 * * {@link Ext.viewport.Viewport Ext.Viewport}
 * * {@link Ext.Img}
 * * {@link Ext.Map}
 * * {@link Ext.Audio}
 * * {@link Ext.Video}
 * * {@link Ext.Sheet}
 * * {@link Ext.ActionSheet}
 * * {@link Ext.MessageBox}
 *
 *
 * ## Instantiating Components
 *
 * Components are created the same way as all other classes in Sencha Touch - using Ext.create. Here's how we can
 * create a Text field:
 *
 *     var panel = Ext.create('Ext.Panel', {
 *         html: 'This is my panel'
 *     });
 *
 * This will create a {@link Ext.Panel Panel} instance, configured with some basic HTML content. A Panel is just a
 * simple Component that can render HTML and also contain other items. In this case we've created a Panel instance but
 * it won't show up on the screen yet because items are not rendered immediately after being instantiated. This allows
 * us to create some components and move them around before rendering and laying them out, which is a good deal faster
 * than moving them after rendering.
 *
 * To show this panel on the screen now we can simply add it to the global Viewport:
 *
 *     Ext.Viewport.add(panel);
 *
 * Panels are also Containers, which means they can contain other Components, arranged by a layout. Let's revisit the
 * above example now, this time creating a panel with two child Components and a hbox layout:
 *
 *     @example
 *     var panel = Ext.create('Ext.Panel', {
 *         layout: 'hbox',
 *
 *         items: [
 *             {
 *                 xtype: 'panel',
 *                 flex: 1,
 *                 html: 'Left Panel, 1/3rd of total size',
 *                  style: 'background-color: #5E99CC;'
 *             },
 *             {
 *                 xtype: 'panel',
 *                 flex: 2,
 *                 html: 'Right Panel, 2/3rds of total size',
 *                  style: 'background-color: #759E60;'
 *             }
 *         ]
 *     });
 *
 *     Ext.Viewport.add(panel);
 *
 * This time we created 3 Panels - the first one is created just as before but the inner two are declared inline using
 * an xtype. Xtype is a convenient way of creating Components without having to go through the process of using
 * Ext.create and specifying the full class name, instead you can just provide the xtype for the class inside an object
 * and the framework will create the components for you.
 *
 * We also specified a layout for the top level panel - in this case hbox, which splits the horizontal width of the
 * parent panel based on the 'flex' of each child. For example, if the parent Panel above is 300px wide then the first
 * child will be flexed to 100px wide and the second to 200px because the first one was given flex: 1 and the second
 * flex: 2.
 *
 * ## Configuring Components
 *
 * Whenever you create a new Component you can pass in configuration options. All of the configurations for a given
 * Component are listed in the &quot;Config options&quot; section of its class docs page. You can pass in any number of
 * configuration options when you instantiate the Component, and modify any of them at any point later. For example, we
 *  can easily modify the {@link Ext.Panel#html html content} of a Panel after creating it:
 *
 *     @example miniphone
 *     //we can configure the HTML when we instantiate the Component
 *     var panel = Ext.create('Ext.Panel', {
 *         fullscreen: true,
 *         html: 'This is a Panel'
 *     });
 *
 *     //we can update the HTML later using the setHtml method:
 *     panel.setHtml('Some new HTML');
 *
 *     //we can retrieve the current HTML using the getHtml method:
 *     alert(panel.getHtml()); //alerts &quot;Some new HTML&quot;
 *
 * Every config has a getter method and a setter method - these are automatically generated and always follow the same
 * pattern. For example, a config called 'html' will receive getHtml and setHtml methods, a config called defaultType
 * will receive getDefaultType and setDefaultType methods, and so on.
 *
 * ## Further Reading
 *
 * See the [Component &amp; Container Guide](#!/guide/components) for more information, and check out the
 * {@link Ext.Container} class docs also.
 *
 */
Ext.define('Ext.Component', {

    extend: 'Ext.AbstractComponent',

    alternateClassName: 'Ext.lib.Component',

    mixins: ['Ext.mixin.Traversable'],

    requires: [
        'Ext.ComponentManager',
        'Ext.XTemplate',
        'Ext.dom.Element',
        'Ext.behavior.Translatable',
        'Ext.behavior.Draggable'
    ],

    xtype: 'component',

    observableType: 'component',

    cachedConfig: {
<span id='Ext-Component-cfg-flex'>        /**
</span>         * @cfg {Number} flex
         */

<span id='Ext-Component-cfg-baseCls'>        /**
</span>         * @cfg {String} baseCls
         * The base CSS class to apply to this components's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the `cls` config.
         * @accessor
         */
        baseCls: null,

<span id='Ext-Component-cfg-cls'>        /**
</span>         * @cfg {String} cls the CSS class to add to this component's element, in addition to the `baseCls`
         * @accessor
         */
        cls: null,

<span id='Ext-Component-cfg-ui'>        /**
</span>         * @cfg {String} ui The ui to be used on this Component
         */
        ui: null,

<span id='Ext-Component-cfg-margin'>        /**
</span>         * @cfg {Number/String} margin The margin to use on this Component. Can be specified as a number (in which case
         * all edges get the same margin) or a CSS string like '5 10 10 10'
         * @accessor
         */
        margin: null,

<span id='Ext-Component-cfg-padding'>        /**
</span>         * @cfg {Number/String} padding The padding to use on this Component. Can be specified as a number (in which
         * case all edges get the same padding) or a CSS string like '5 10 10 10'
         * @accessor
         */
        padding: null,

<span id='Ext-Component-cfg-border'>        /**
</span>         * @cfg {Number/String} border The border to use on this Component. Can be specified as a number (in which
         * case all edges get the same border width) or a CSS string like '5 10 10 10'
         * @accessor
         */
        border: null,

<span id='Ext-Component-cfg-styleHtmlCls'>        /**
</span>         * @cfg {String} styleHtmlCls
         * The class that is added to the content target when you set styleHtmlContent to true.
         * @accessor
         */
        styleHtmlCls: clsPrefix + 'html',

<span id='Ext-Component-cfg-styleHtmlContent'>        /**
</span>         * @cfg {Boolean} [styleHtmlContent=false]
         * True to automatically style the html inside the content target of this component (body for panels).
         * @accessor
         */
        styleHtmlContent: null,

        hidden: false
    },

    eventedConfig: {
<span id='Ext-Component-cfg-left'>        /**
</span>         * @cfg {Number/Boolean} left
         * @accessor
         * @evented
         */
        left: null,

<span id='Ext-Component-cfg-top'>        /**
</span>         * @cfg {Number/Boolean} top
         * @accessor
         * @evented
         */
        top: null,

<span id='Ext-Component-cfg-right'>        /**
</span>         * @cfg {Number/Boolean} right
         * @accessor
         * @evented
         */
        right: null,

<span id='Ext-Component-cfg-bottom'>        /**
</span>         * @cfg {Number/Boolean} bottom
         * @accessor
         * @evented
         */
        bottom: null,

<span id='Ext-Component-cfg-width'>        /**
</span>         * @cfg {Number} width
         * The width of this component in pixels.
         * @accessor
         * @evented
         */
        width: null,

<span id='Ext-Component-cfg-height'>        /**
</span>         * @cfg {Number} height
         * The height of this component in pixels.
         * @accessor
         * @evented
         */
        height: null,

<span id='Ext-Component-cfg-docked'>        /**
</span>         * @cfg {String} docked
         * The dock position of this component in its container. Can be 'left', 'top', 'right' or 'bottom'.
         * @accessor
         * @evented
         */
        docked: null,

<span id='Ext-Component-cfg-centered'>        /**
</span>         * @cfg {Boolean} centered
         * Whether or not this component is absolutely centered inside its container
         * @accessor
         * @evented
         */
        centered: null,

<span id='Ext-Component-cfg-hidden'>        /**
</span>         * @cfg {Boolean} hidden
         * Whether or not this component is hidden
         * @accessor
         * @evented
         */
        hidden: null,

<span id='Ext-Component-cfg-disabled'>        /**
</span>         * @cfg {Boolean} disabled
         * Whether or not this component is disabled
         * @accessor
         * @evented
         */
        disabled: null
    },

    config: {
<span id='Ext-Component-cfg-style'>        /**
</span>         * @cfg {String/Object} style Optional CSS styles that will be rendered into an inline style attribute when the
         * Component is rendered
         * @accessor
         */
        style: null,

<span id='Ext-Component-cfg-html'>        /**
</span>         * @cfg {String/Ext.Element/HTMLElement} html Optional HTML content to render inside this Component, or a reference
         * to an existing element on the page.
         * @accessor
         */
        html: null,

<span id='Ext-Component-cfg-draggable'>        /**
</span>         * @cfg {Object} draggable Configuration options to make this Component draggable
         * @accessor
         */
        draggable: null,

<span id='Ext-Component-cfg-translatable'>        /**
</span>         * @cfg {Object} translatable
         * @private
         * @accessor
         */
        translatable: null,

<span id='Ext-Component-cfg-droppable'>        /**
</span>         * @cfg {Object} droppable Configuration options to make this Component droppable
         * @accessor
         */
        droppable: null,

<span id='Ext-Component-cfg-renderTo'>        /**
</span>         * @cfg {Ext.Element} renderTo Optional element to render this Component to. Usually this is not needed because
         * a Component is normally full screen or automatically rendered inside another {@link Ext.Container Container}
         * @accessor
         */
        renderTo: null,

<span id='Ext-Component-cfg-zIndex'>        /**
</span>         * @cfg {Number} zIndex The z-index to give this Component when it is rendered
         * @accessor
         */
        zIndex: null,

<span id='Ext-Component-cfg-tpl'>        /**
</span>         * @cfg {Mixed} tpl
         * An &lt;bold&gt;{@link Ext.Template}&lt;/bold&gt;, &lt;bold&gt;{@link Ext.XTemplate}&lt;/bold&gt;
         * or an array of strings to form an Ext.XTemplate.
         * Used in conjunction with the &lt;code&gt;{@link #data}&lt;/code&gt; and
         * &lt;code&gt;{@link #tplWriteMode}&lt;/code&gt; configurations.
         * @accessor
         */
        tpl: null,

<span id='Ext-Component-cfg-renderTpl'>        /**
</span>         * @cfg {Mixed} renderTpl
         * &lt;p&gt;An {@link Ext.XTemplate XTemplate} used to create the internal structure inside this Component's
         * encapsulating Element.&lt;/p&gt;
         * &lt;p&gt;You do not normally need to specify this. For the base classes {@link Ext.Component}
         * and {@link Ext.Container}, this defaults to &lt;b&gt;&lt;code&gt;null&lt;/code&gt;&lt;/b&gt; which means that they will be initially rendered
         * with no internal structure; they render their {@link #getEl Element} empty. The more specialized ExtJS and Touch classes
         * which use a more complex DOM structure, provide their own template definitions.&lt;/p&gt;
         * &lt;p&gt;This is intended to allow the developer to create application-specific utility Components with customized
         * internal structure.&lt;/p&gt;
         * @accessor
         */

<span id='Ext-Component-cfg-tplWriteMode'>        /**
</span>         * @cfg {String} tplWriteMode The Ext.(X)Template method to use when
         * updating the content area of the Component. Defaults to &lt;code&gt;'overwrite'&lt;/code&gt;
         * (see &lt;code&gt;{@link Ext.XTemplate#overwrite}&lt;/code&gt;).
         * @accessor
         */
        tplWriteMode: 'overwrite',

<span id='Ext-Component-cfg-data'>        /**
</span>         * @cfg {Mixed} data
         * The initial set of data to apply to the &lt;code&gt;{@link #tpl}&lt;/code&gt; to
         * update the content area of the Component.
         * @accessor
         */
        data: null,

<span id='Ext-Component-cfg-disabledCls'>        /**
</span>         * @cfg {String} disabledCls The CSS class to add to the component when it is disabled
         * @accessor
         */
        disabledCls: clsPrefix + 'item-disabled',

<span id='Ext-Component-cfg-modal'>        /**
</span>         * @cfg {Boolean} modal True to make this Component modal. This will create a mask underneath the Component
         * that covers the whole page and does not allow the user to interact with any other Components until this
         * Component is dismissed
         * @accessor
         */
        modal: null,

<span id='Ext-Component-cfg-hideOnMaskTap'>        /**
</span>         * @cfg {Boolean} hideOnMaskTap When using a {@link #modal} Component, setting this to true (the default) will
         * hide the modal mask and the Component when the mask is tapped on
         * @accessor
         */
        hideOnMaskTap: true,

<span id='Ext-Component-cfg-contentEl'>        /**
</span>         * @cfg {Ext.Element/HTMLElement/String} contentEl The configured element will automatically be added as the content of this
         * component. When you pass a string, we expect it to be an element id. If the content element is hidden, we will automatically
         * show it.
         * @accessor
         */
        contentEl: null,

<span id='Ext-Component-cfg-itemId'>        /**
</span>         * @cfg {String} itemId
         * @accessor
         */
        itemId: undefined,

<span id='Ext-Component-cfg-plugins'>        /**
</span>         * @cfg {Object/Array} plugins
         * @accessor
         * An object or array of objects that will provide custom functionality for this component.  The only
         * requirement for a valid plugin is that it contain an init method that accepts a reference of type Ext.Component.
         * When a component is created, if any plugins are available, the component will call the init method on each
         * plugin, passing a reference to itself.  Each plugin can then call methods or respond to events on the
         * component as needed to provide its functionality.
         */
        plugins: null,

        elementListeners: null
    },

<span id='Ext-Component-event-painted'>    /**
</span>     * @event painted
     * Fires whenever the Component is moved into to the DOM body
     * @param {Ext.Component} this The component instance
     */

<span id='Ext-Component-event-erased'>    /**
</span>     * @event erased
     * Fires whenever the Component is moved out of the DOM body
     * @param {Ext.Component} this The component instance
     */

<span id='Ext-Component-event-show'>    /**
</span>     * @event show
     * Fires whenever the Component is shown
     * @param {Ext.Component} this The component instance
     */

<span id='Ext-Component-event-hide'>    /**
</span>     * @event hide
     * Fires whenever the Component is hidden
     * @param {Ext.Component} this The component instance
     */

<span id='Ext-Component-event-fullscreen'>    /**
</span>     * @event fullscreen
     * Fires whenever a Component with the fullscreen config is instantiated
     * @param {Ext.Component} this The component instance
     */

<span id='Ext-Component-event-floatingchange'>    /**
</span>     * @event floatingchange
     * Fires whenever there is a change in the floating status of a component
     * @param {Ext.Component} this The component instance
     * @param {Boolean} floating The component's new floating state
     */

<span id='Ext-Component-property-alignPositionMap'>    /**
</span>     * @private
     */
    alignPositionMap: [
        'tl-bl',
        't-b',
        'tr-br',
        'l-r',
        'l-r',
        'r-l',
        'bl-tl',
        'b-t',
        'br-tr'
    ],

<span id='Ext-Component-property-isComponent'>    /**
</span>     * @private
     */
    isComponent: true,

<span id='Ext-Component-property-floating'>    /**
</span>     * @private
     */
    floating: false,

<span id='Ext-Component-property-rendered'>    /**
</span>     * @private
     */
    rendered: false,

<span id='Ext-Component-property-dockPositions'>    /**
</span>     * @readonly
     */
    dockPositions: {
        top: true,
        right: true,
        bottom: true,
        left: true
    },

    innerElement: null,

    element: null,

    template: [],

<span id='Ext-Component-method-constructor'>    /**
</span>     * Creates new Component.
     * @param {Object} config The standard configuration object.
     */
    constructor: function(config) {
        if (config &amp;&amp; config.id) {
            this.id = config.id;
            delete config.id;
        }
        else {
            this.getId();
        }

        Ext.ComponentManager.register(this);

        this.callParent(arguments);

<span id='Ext-Component-cfg-fullscren'>        /**
</span>         * Force the component to take up 100% width and height available, by adding it to {@link Ext.viewport.Viewport}.
         * @cfg {Boolean} fullscren
         */
        if ('fullscreen' in this.config) {
            this.fireEvent('fullscreen', this);
        }
    },

    getTemplate: function() {
        return this.template;
    },

    getElementConfig: function() {
        return {
            reference: 'element',
            children: this.getTemplate()
        };
    },

<span id='Ext-Component-method-getEl'>    /**
</span>     * Retrieves the top level element representing this component.
     * @return {Ext.dom.Element}
     */
    getEl: function() {
        return this.renderElement;
    },

    renderTo: function(container, insertBeforeElement) {
        var dom = this.renderElement.dom,
            containerDom = Ext.getDom(container),
            insertBeforeChildDom = Ext.getDom(insertBeforeElement);

        if (containerDom) {
            if (insertBeforeChildDom) {
                containerDom.insertBefore(dom, insertBeforeChildDom);
            }
            else {
                containerDom.appendChild(dom);
            }

            this.setRendered(Boolean(dom.offsetParent));
        }
    },

    setParent: function(parent) {
        var currentParent = this.parent;

        if (parent &amp;&amp; currentParent &amp;&amp; currentParent !== parent) {
            currentParent.remove(this, false);
        }

        this.parent = parent;

        return this;
    },

    applyElementListeners: function(listeners) {
        this.element.on(listeners);
    },

    applyPlugins: function(config) {
        var ln, i;

        if (!config) {
            return config;
        }

        config = [].concat(config);

        for (i = 0, ln = config.length; i &lt; ln; i++) {
            config[i] = Ext.factory(config[i], 'Ext.plugin.Plugin', null, 'plugin');
        }

        return config;
    },

    updatePlugins: function(newPlugins, oldPlugins) {
        var ln, i;

        if (newPlugins) {
            for (i = 0, ln = newPlugins.length; i &lt; ln; i++) {
                newPlugins[i].init(this);
            }
        }

        if (oldPlugins) {
            for (i = 0, ln = oldPlugins.length; i &lt; ln; i++) {
                Ext.destroy(oldPlugins[i]);
            }
        }
    },

    updateRenderTo: function(newContainer) {
        this.renderTo(newContainer);
    },

    updateStyle: function(style) {
        this.element.dom.setAttribute('style', style);
    },

    updateBorder: function(border) {
        this.element.setBorder(border);
    },

    updatePadding: function(padding) {
       this.innerElement.setPadding(padding);
    },

    updateMargin: function(margin) {
        this.element.setMargin(margin);
    },

    updateUi: function(newUi, oldUi) {
        var baseCls = this.getBaseCls();

        if (baseCls) {
            if (newUi) {
                this.addCls(newUi, baseCls);
            }

            if (oldUi) {
                this.removeCls(oldUi, baseCls);
            }
        }
    },

    applyBaseCls: function(baseCls) {
        return baseCls || clsPrefix + this.xtype;
    },

    updateBaseCls: function(newBaseCls, oldBaseCls) {
        var me = this,
            ui = me.getUi();

        if (newBaseCls) {
            this.addCls(newBaseCls);

            if (ui) {
                this.addCls(newBaseCls, null, ui);
            }
        }

        if (oldBaseCls) {
            this.removeCls(oldBaseCls);

            if (ui) {
                this.removeCls(oldBaseCls, null, ui);
            }
        }
    },

    updateCls: function(cls, oldCls) {
        this.replaceCls(oldCls, cls);
    },

<span id='Ext-Component-method-updateStyleHtmlCls'>    /**
</span>     * Updates the {@link #styleHtmlCls} configuration
     */
    updateStyleHtmlCls: function(newHtmlCls, oldHtmlCls) {
        var innerHtmlElement = this.innerHtmlElement,
            innerElement = this.innerElement;

        if (this.getStyleHtmlContent() &amp;&amp; oldHtmlCls) {
            if (innerHtmlElement) {
                innerHtmlElement.replaceCls(oldHtmlCls, newHtmlCls);
            } else {
                innerElement.replaceCls(oldHtmlCls, newHtmlCls);
            }
        }
    },

    applyStyleHtmlContent: function(config) {
        return Boolean(config);
    },

    updateStyleHtmlContent: function(styleHtmlContent) {
        var htmlCls = this.getStyleHtmlCls(),
            innerElement = this.innerElement,
            innerHtmlElement = this.innerHtmlElement;

        if (styleHtmlContent) {
            if (innerHtmlElement) {
                innerHtmlElement.addCls(htmlCls);
            } else {
                innerElement.addCls(htmlCls);
            }
        } else {
            if (innerHtmlElement) {
                innerHtmlElement.removeCls(htmlCls);
            } else {
                innerElement.addCls(htmlCls);
            }
        }
    },

    applyContentEl: function(contentEl) {
        if (contentEl) {
            return Ext.get(contentEl);
        }
    },

    updateContentEl: function(newContentEl, oldContentEl) {
        if (oldContentEl) {
            oldContentEl.hide();
            Ext.getBody().append(oldContentEl);
        }
        if (newContentEl) {
            this.setHtml(newContentEl);
            newContentEl.show();
        }
    },

<span id='Ext-Component-method-getSize'>    /**
</span>     * Returns the height and width of the Component
     * @return {Object} The current height and width of the Component
     */
    getSize: function() {
        return {
            width: this.getWidth(),
            height: this.getHeight()
        };
    },

    isCentered: function() {
        return Boolean(this.getCentered());
    },

    isFloating: function() {
        return this.floating;
    },

    isDocked: function() {
        return Boolean(this.getDocked());
    },

    isInnerItem: function() {
        var me = this;
        return !me.isCentered() &amp;&amp; !me.isFloating() &amp;&amp; !me.isDocked();
    },

    filterPositionValue: function(value) {
        if (value === '' || value === 'auto') {
            value = null;
        }

        return value;
    },

    applyTop: function(top) {
        return this.filterPositionValue(top);
    },

    applyRight: function(right) {
        return this.filterPositionValue(right);
    },

    applyBottom: function(bottom) {
        return this.filterPositionValue(bottom);
    },

    applyLeft: function(left) {
        return this.filterPositionValue(left);
    },

    doSetTop: function(top) {
        this.updateFloating();
        this.element.setTop(top);
    },

    doSetRight: function(right) {
        this.updateFloating();
        this.element.setRight(right);
    },

    doSetBottom: function(bottom) {
        this.updateFloating();
        this.element.setBottom(bottom);
    },

    doSetLeft: function(left) {
        this.updateFloating();
        this.element.setLeft(left);
    },

    doSetWidth: function(width) {
        this.element.setWidth(width);
    },

    doSetHeight: function(height) {
        this.element.setHeight(height);
    },

    //TODO Implement animations here
//    animatePosition: function(property, value, animation) {
//        var me = this,
//            config = {};
//
//        animation = Ext.factory(animation || true, Ext.fx.Animation);
//        animation.setElement(this.element);
//        animation.setBefore({
//            position: 'absolute'
//        });
//        animation.getFrom().set(property, this.getConfig(property));
//        animation.getTo().set(property, value);
//        animation.setAfter({
//            position: null
//        });
//        animation.setOnEnd(function() {
//            me.setConfig(config);
//        });
//
//        config[property] = value;
//
//        Ext.Animator.run(animation);
//    },
//
//    animateSize: function(property, value, animation) {
//
//    },
//
//    animateVisibility: function(value, animation) {
//
//    },

    applyCentered: function(centered) {
        centered = Boolean(centered);

        if (centered) {
            if (this.isFloating()) {
                this.resetFloating();
            }

            if (this.isDocked()) {
                this.setDocked(false);
            }
        }

        return centered;
    },

    doSetCentered: Ext.emptyFn,

    applyDocked: function(docked) {
        if (docked) {
            if (!this.dockPositions[docked]) {
                //&lt;debug error&gt;
                Ext.Logger.error(&quot;Invalid docking position of '&quot; + docked + &quot;', must be either 'top', 'right', 'bottom', &quot; +
                    &quot;'left' or `null` (for no docking)&quot;, this);
                //&lt;/debug&gt;
                return;
            }

            if (this.isFloating()) {
                this.resetFloating();
            }

            if (this.isCentered()) {
                this.setCentered(false);
            }
        }

        return docked;
    },

    doSetDocked: Ext.emptyFn,

    resetFloating: function() {
        this.setTop(null);
        this.setRight(null);
        this.setBottom(null);
        this.setLeft(null);
    },

    updateFloating: function() {
        var floating = true;

        if (this.getTop() === null &amp;&amp; this.getBottom() === null &amp;&amp; this.getRight() === null &amp;&amp; this.getLeft() === null) {
            floating = false;
        }

        if (floating !== this.floating) {
            if (floating) {
                if (this.isCentered()) {
                    this.setCentered(false);
                }

                if (this.isDocked()) {
                    this.setDocked(false);
                }
            }

            this.floating = floating;
            this.fireEvent('floatingchange', this, floating);
        }
    },

    applyDisabled: function(disabled) {
        return Boolean(disabled);
    },

    doSetDisabled: function(disabled) {
        this.element[disabled ? 'addCls' : 'removeCls'](this.getDisabledCls());
    },

<span id='Ext-Component-method-disable'>    /**
</span>     * Disables this Component
     */
    disable: function() {
       this.setDisabled(true);
    },

<span id='Ext-Component-method-enable'>    /**
</span>     * Enables this Component
     */
    enable: function() {
        this.setDisabled(false);
    },

<span id='Ext-Component-method-isDisabled'>    /**
</span>     * Returns true if this Component is currently disabled
     * @return {Boolean} True if currently disabled
     */
    isDisabled: function() {
        return this.getDisabled();
    },

    updateZIndex: function(zIndex) {
        this.element.dom.style.zIndex = zIndex;
    },

    getInnerHtmlElement: function() {
        var innerHtmlElement = this.innerHtmlElement,
            styleHtmlCls = this.getStyleHtmlCls();

        if (!innerHtmlElement || !innerHtmlElement.dom || !innerHtmlElement.dom.parentNode) {
            this.innerHtmlElement = innerHtmlElement = this.innerElement.createChild({ cls: 'x-innerhtml ' });

            if (this.getStyleHtmlContent()) {
                this.innerHtmlElement.addCls(styleHtmlCls);
                this.innerElement.removeCls(styleHtmlCls);
            }
        }

        return innerHtmlElement;
    },

    updateHtml: function(html) {
        var innerHtmlElement = this.getInnerHtmlElement();
        if (typeof html === 'string') {
            innerHtmlElement.setHtml(html);
        } else {
            innerHtmlElement.setHtml('');
            innerHtmlElement.append(html);
        }
    },

    applyHidden: function(hidden) {
        return Boolean(hidden);
    },

    doSetHidden: function(hidden) {
        var element = this.renderElement;

        if (hidden) {
            element.hide();
        }
        else {
            element.show();
        }
    },

<span id='Ext-Component-method-isHidden'>    /**
</span>     * Returns true if this Component is currently hidden
     * @return {Boolean} True if currently hidden
     */
    isHidden: function() {
        return this.getHidden();
    },

<span id='Ext-Component-method-hide'>    /**
</span>     * Hides this Component
     */
    hide: function() {
        this.setHidden(true);
    },

<span id='Ext-Component-method-show'>    /**
</span>     * Shows this component
     */
    show: function() {
        this.setHidden(false);
    },

<span id='Ext-Component-method-isRendered'>    /**
</span>     * @private
     */
    isRendered: function() {
        return this.rendered;
    },

<span id='Ext-Component-method-isPainted'>    /**
</span>     * @private
     */
    isPainted: function() {
        return this.renderElement.isPainted();
    },

<span id='Ext-Component-method-applyTpl'>    /**
</span>     * @private
     */
    applyTpl: function(config) {
        return (Ext.isObject(config) &amp;&amp; config.isTemplate) ? config : new Ext.XTemplate(config);
    },

<span id='Ext-Component-method-updateData'>    /**
</span>     * @private
     */
    updateData: function(newData) {
        var me = this;
        if (newData) {
            var tpl = me.getTpl(),
                tplWriteMode = me.getTplWriteMode();

            if (tpl) {
                tpl[tplWriteMode](me.getInnerHtmlElement(), newData);
            }
        }
    },

<span id='Ext-Component-method-addCls'>    /**
</span>     * Adds a CSS class (or classes) to this Component's rendered element
     * @param {String} cls The CSS class to add
     * @param {String} prefix Optional prefix to add to each class
     * @param {String} suffix Optional suffix to add to each class
     */
    addCls: function(cls, prefix, suffix) {
        this.element.addCls(cls, prefix, suffix);
    },

<span id='Ext-Component-method-removeCls'>    /**
</span>     * Removes the given CSS class(es) from this Component's rendered element
     * @param {String} cls The class(es) to remove
     * @param {String} prefix Optional prefix to prepend before each class
     * @param {String} suffix Optional suffix to append to each class
     */
    removeCls: function(cls, prefix, suffix) {
        this.element.removeCls(cls, prefix, suffix);
    },

    replaceCls: function(oldCls, newCls, prefix, suffix) {
        this.element.replaceCls(oldCls, newCls, prefix, suffix);
    },

    applyItemId: function(itemId) {
        return itemId || this.getId();
    },

    //TODO Deprecate this method name, should have been 'isXtype' (lowercased 't')
<span id='Ext-Component-method-isXType'>    /**
</span>     * &lt;p&gt;Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
     * from the xtype (default) or whether it is directly of the xtype specified (shallow = true).&lt;/p&gt;
     * &lt;p&gt;&lt;b&gt;If using your own subclasses, be aware that a Component must register its own xtype
     * to participate in determination of inherited xtypes.&lt;/b&gt;&lt;/p&gt;
     * &lt;p&gt;For a list of all available xtypes, see the {@link Ext.Component} header.&lt;/p&gt;
     * &lt;p&gt;Example usage:&lt;/p&gt;
     * &lt;pre&gt;&lt;code&gt;
var t = new Ext.field.Text();
var isText = t.isXType('textfield');        // true
var isBoxSubclass = t.isXType('field');       // true, descended from Ext.field.Field
var isBoxInstance = t.isXType('field', true); // false, not a direct Ext.field.Field instance
&lt;/code&gt;&lt;/pre&gt;
     * @param {String} xtype The xtype to check for this Component
     * @param {Boolean} shallow (optional) False to check whether this Component is descended from the xtype (this is
     * the default), or true to check whether this Component is directly of the specified xtype.
     * @return {Boolean} True if this component descends from the specified xtype, false otherwise.
     */
    isXType: function(xtype, shallow) {
        if (shallow) {
            return this.xtypes.indexOf(xtype) != -1;
        }

        return Boolean(this.xtypesMap[xtype]);
    },

    //TODO Correct this method's signature should return the array of xtypes instead of a string. Also
    // its name should be getXtypes (lowercased 't')
<span id='Ext-Component-method-getXTypes'>    /**
</span>     * &lt;p&gt;Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
     * available xtypes, see the {@link Ext.Component} header.&lt;/p&gt;
     * &lt;p&gt;&lt;b&gt;If using your own subclasses, be aware that a Component must register its own xtype
     * to participate in determination of inherited xtypes.&lt;/b&gt;&lt;/p&gt;
     * &lt;p&gt;Example usage:&lt;/p&gt;
     * &lt;pre&gt;&lt;code&gt;
var t = new Ext.field.Text();
alert(t.getXTypes());  // alerts 'component/field/textfield'
&lt;/code&gt;&lt;/pre&gt;
     * @return {String} The xtype hierarchy string
     */
    getXTypes: function() {
        return this.xtypesChain.join('/');
    },

    getDraggableBehavior: function() {
        var behavior = this.draggableBehavior;

        if (!behavior) {
            behavior = this.draggableBehavior = new Ext.behavior.Draggable(this);
        }

        return behavior;
    },

    applyDraggable: function(config) {
        this.getDraggableBehavior().setConfig(config);
    },

    getDraggable: function() {
        return this.getDraggableBehavior().getDraggable();
    },

    getTranslatableBehavior: function() {
        var behavior = this.translatableBehavior;

        if (!behavior) {
            behavior = this.translatableBehavior = new Ext.behavior.Translatable(this);
        }

        return behavior;
    },

    applyTranslatable: function(config) {
        this.getTranslatableBehavior().setConfig(config);
    },

    getTranslatable: function() {
        return this.getTranslatableBehavior().getTranslatable();
    },

    translate: function() {
        var translatable = this.getTranslatable();

        if (!translatable) {
            this.setTranslatable(true);
            translatable = this.getTranslatable();
        }

        translatable.translate.apply(translatable, arguments);
    },

    setRendered: function(rendered) {
        var wasRendered = this.rendered;

        if (rendered !== wasRendered) {
            this.rendered = rendered;

            return true;
        }

        return false;
    },

<span id='Ext-Component-method-setSize'>    /**
</span>     * Sets the size of the Component
     * @param {Number} width The new width for the Component
     * @param {Number} height The new height for the Component
     */
    setSize: function(width, height) {
        if (width != undefined) {
            this.setWidth(width);
        }
        if (height != undefined) {
            this.setHeight(height);
        }
    },

    //TODO Need serious rewrites from here on or move them to the proper places
<span id='Ext-Component-method-showBy'>    /**
</span>     * Shows this Component next to another Component or Element
     * @param {Ext.Component/Ext.Element} alignTo The Element or Component to align to
     */
    showBy: function(alignTo, animation, anchor) {
        // @todo animation + allowOnSide not implemented
        //&lt;debug warn&gt;
        if (animation) {
            Ext.Logger.warn('showBy: animation argument not implemented.');
        }
        //&lt;/debug&gt;

        var parent = this.getParent();
        if (parent) {
            parent.remove(this, false);
        }

        Ext.Viewport.add(this);

        this.setTop(-10000);
        this.setLeft(-10000);
        this.show();

        this.alignTo(alignTo, anchor || 'auto');

        // If we don't do a repaint here, on iOS5 iPhone/iPod, the element will not be positioned correctly
        // on the screen
        this.element.repaint();
    },

    anchorRe: /^([a-z]+)-([a-z]+)(\?)?$/,

    doAnchorXY: function(anchor, box, toBox, constrainBox) {
        var matches = anchor.match(this.anchorRe),
            fromAnchor = matches[1].split(''),
            toAnchor = matches[2].split(''),
            offsetBox = {top: toBox.top, left: toBox.left},
            constrain = (matches[3] === '?'),

            fromVertical = fromAnchor[0],
            fromHorizontal = fromAnchor[1] || fromVertical,

            toVertical = toAnchor[0],
            toHorizontal = toAnchor[1] || toVertical,

            maxLeft, maxTop;

        switch (fromVertical) {
            case 't':
                switch (toVertical) {
                    case 'c':
                        offsetBox.top += toBox.height / 2;
                        break;
                    case 'b':
                        offsetBox.top += toBox.height;
                }
                break;

            case 'b':
                switch (toVertical) {
                    case 'c':
                        offsetBox.top -= (box.height - (toBox.height / 2));
                        break;
                    case 't':
                        offsetBox.top -= box.height;
                }
                break;

            case 'c':
                 switch (toVertical) {
                    case 't':
                        offsetBox.top -= (box.height / 2);
                        break;
                    case 'c':
                        offsetBox.top -= ((box.height / 2) - (toBox.height / 2));
                        break;
                    case 'b':
                        offsetBox.top -= ((box.height / 2) - toBox.height);
                }
                break;
        }

        switch (fromHorizontal) {
            case 'l':
                switch (toHorizontal) {
                    case 'c':
                        offsetBox.left += toBox.width / 2;
                        break;
                    case 'r':
                        offsetBox.left += toBox.width;
                }
                break;

            case 'r':
                switch (toHorizontal) {
                    case 'r':
                        offsetBox.left -= (box.width - toBox.width);
                        break;
                    case 'c':
                        offsetBox.left -= (box.width - (toBox.width / 2));
                        break;
                    case 'l':
                        offsetBox.left -= box.width;
                }
                break;

            case 'c':
                 switch (toHorizontal) {
                    case 'l':
                        offsetBox.left -= (box.width / 2);
                        break;
                    case 'c':
                        offsetBox.left -= ((box.width / 2) - (toBox.width / 2));
                        break;
                    case 'r':
                        offsetBox.left -= ((box.width / 2) - toBox.width);
                }
                break;
        }

        if (constrain) {
            maxLeft = (constrainBox.left + constrainBox.width) - box.width;
            maxTop = (constrainBox.top + constrainBox.height) - box.height;

            offsetBox.left = Math.max(constrainBox.left, Math.min(maxLeft, offsetBox.left));
            offsetBox.top = Math.max(constrainBox.top, Math.min(maxTop, offsetBox.top));
        }

        return offsetBox;
    },

    alignTo : function(alignTo, anchor, offset) {
        offset = offset || 0;

        var alignElement = alignTo.element,
            alignXY = webkitConvertPointFromNodeToPage(alignElement.dom, new WebKitPoint()),
            alignSize = alignElement.getSize(),
            size = this.element.getSize(),
            parent = this.getParent(),
            constrainBox = (parent) ? parent.element.getBox() : Ext.getBody().getBox(),
            box = {
                left: 0,
                top: 0,
                width: size.width,
                height: size.height
            },
            relativeToBox = {
                left: alignXY.x,
                top: alignXY.y,
                width: alignSize.width,
                height: alignSize.height
            }, anchorBox, tmpBox;

        if (anchor == 'auto') {
            anchor = 'tc-bc';
        }

        anchorBox = this.doAnchorXY(anchor, box, relativeToBox, constrainBox);
        if (anchorBox.top + box.height &gt; constrainBox.top + constrainBox.height) {
            tmpBox = this.doAnchorXY('bc-tc?', box, relativeToBox, constrainBox);
            anchorBox.top = tmpBox.top;
        }
        if (anchorBox.left + box.width &gt; constrainBox.left + constrainBox.width) {
            tmpBox = this.doAnchorXY('br-tr?', box, relativeToBox, constrainBox);
            anchorBox.left = tmpBox.left;
        } else if (anchorBox.left &lt; constrainBox.left) {
            tmpBox = this.doAnchorXY('bl-tl?', box, relativeToBox, constrainBox);
            anchorBox.left = tmpBox.left;
        }

        this.setTop(anchorBox.top);
        this.setLeft(anchorBox.left);
    },

<span id='Ext-Component-method-up'>    /**
</span>     * &lt;p&gt;Walks up the &lt;code&gt;ownerCt&lt;/code&gt; axis looking for an ancestor Container which matches
     * the passed simple selector.&lt;/p&gt;
     * &lt;p&gt;Example:&lt;pre&gt;&lt;code&gt;
var owningTabPanel = grid.up('tabpanel');
&lt;/code&gt;&lt;/pre&gt;
     * @param {String} selector Optional. The simple selector to test.
     * @return {Ext.Container} The matching ancestor Container (or &lt;code&gt;undefined&lt;/code&gt; if no match was found).
     */
    up: function(selector) {
        var result = this.parent;

        if (selector) {
            for (; result; result = result.parent) {
                if (Ext.ComponentQuery.is(result, selector)) {
                    return result;
                }
            }
        }
        return result;
    },

<span id='Ext-Component-method-destroy'>    /**
</span>     * Destroys this Component. If it is currently added to a Container it will first be removed from that Container.
     * All Ext.Element references are also deleted and the Component is de-registered from Ext.ComponentManager
     */
    destroy: function() {
        this.callParent();

        var parent = this.getParent(),
            referenceList = this.referenceList,
            i, ln, reference;

        // Remove this component itself from the container if it's currently contained
        if (parent) {
            parent.remove(this, false);
        }

        // Destroy all element references
        for (i = 0,ln = referenceList.length; i &lt; ln; i++) {
            reference = referenceList[i];
            this[reference].destroy();
            delete this[reference];
        }

        Ext.ComponentManager.unregister(this);
    }

}, function() {
   //&lt;deprecated product=touch since=2.0&gt;
    var emptyFn = Ext.emptyFn;

    this.override({
        constructor: function(config) {
            var name;

            if (config) {
                if (config.enabled) {
                    //&lt;debug warn&gt;
                    Ext.Logger.deprecate(&quot;'enabled' config is deprecated, please use 'disabled' config instead&quot;, this);
                    //&lt;/debug&gt;
                    config.disabled = !config.enabled;
                }

                if ((config.scroll || this.config.scroll || this.scrollable || this.config.scrollable) &amp;&amp; !this.isContainer) {
                    //&lt;debug warn&gt;
                    Ext.Logger.deprecate(&quot;You are no longer able to scroll a component. Please use a Ext.Container instead.&quot;, this);
                    //&lt;/debug&gt;
                    delete config.scrollable;
                    delete config.scroll;
                }

                if (config.dock) {
                    //&lt;debug warn&gt;
                    Ext.Logger.deprecate(&quot;'dock' config for docked items is deprecated, please use 'docked' instead&quot;);
                    //&lt;/debug&gt;
                    config.docked = config.dock;
                    delete config.dock;
                }

<span id='Ext-Component-cfg-componentCls'>                /**
</span>                 * @member Ext.Component
                 * @cfg {String} componentCls CSS class to add to this Component. Deprecated, please use {@link #cls} instead
                 * @deprecated 2.0.0
                 */
                if (config.componentCls) {
                    //&lt;debug warn&gt;
                    Ext.Logger.deprecate(&quot;'componentCls' config is deprecated, please use 'cls' config instead&quot;, this);
                    //&lt;/debug&gt;
                    config.cls = config.componentCls;
                }

                for (name in config) {
                    if (config.hasOwnProperty(name) &amp;&amp; name !== 'xtype' &amp;&amp; name !== 'xclass' &amp;&amp; !this.hasConfig(name)) {
                        this[name] = config[name];
                    }
                }
            }

            this.callParent(arguments);

            if (this.onRender !== emptyFn) {
                //&lt;debug warn&gt;
                Ext.Logger.deprecate(&quot;onRender() is deprecated, please put your code inside initialize() instead&quot;, this);
                //&lt;/debug&gt;
                this.onRender();
            }

            if (this.afterRender !== emptyFn) {
                //&lt;debug warn&gt;
                Ext.Logger.deprecate(&quot;afterRender() is deprecated, please put your code inside initialize() instead&quot;, this);
                //&lt;/debug&gt;
                this.afterRender();
            }

            if (this.initEvents !== emptyFn) {
                //&lt;debug warn&gt;
                Ext.Logger.deprecate(&quot;initEvents() is deprecated, please put your code inside initialize() instead&quot;, this);
                //&lt;/debug&gt;
                this.initEvents();
            }

            if (this.initComponent !== emptyFn) {
                //&lt;debug warn&gt;
                Ext.Logger.deprecate(&quot;initComponent() is deprecated, please put your code inside initialize() instead&quot;, this);
                //&lt;/debug&gt;
                this.initComponent();
            }
        },

        onRender: emptyFn,

        afterRender: emptyFn,

        initEvents: emptyFn,

        initComponent: emptyFn,

        show: function() {
            if (this.renderElement.dom) {
                var containerDom = this.renderElement.dom.parentNode;

                if (containerDom &amp;&amp; containerDom.nodeType == 11) {
                    //&lt;debug warn&gt;
                    Ext.Logger.deprecate(&quot;Showing a component that currently doesn't have any container, &quot; +
                        &quot;please use Ext.Viewport.add() to add this component to the viewport&quot;, this);
                    //&lt;/debug&gt;
                    Ext.Viewport.add(this);
                }
            }

            return this.callParent(arguments);
        },

        doSetHidden: function(hidden) {
            this.callParent(arguments);

            this.fireEvent(hidden ? 'hide' : 'show', this);
        }
    });

<span id='Ext-Component-method-update'>    /**
</span>     * @member Ext.Component
     * @method update
     * @deprecated 2.0.0
     * Updates the HTML content of the Component. Deprecated, please use {@link #setHtml} instead
     */

    Ext.deprecateClassMembers(this, {
        el: 'element',
        body: 'element',
        outer: 'renderElement',
        ownerCt: 'parent',
        update: 'setHtml'
    });
    //&lt;/deprecated&gt;
});

})(Ext.baseCSSPrefix);
</pre>
</body>
</html>
